#+STARTUP: indent
* beginning
*Version control with Git*. \\
Undoing things a la Git. \\
- git status : everything is fine
- rm -rf app/controllers
- git status : D'oh!
- git checkout -f : undo the changes of the working tree by force
  overwriting the current changes.

* Mostly Static Pages
The application will eventually have users, microposts, and a full
login and authentication framework. \\
We begin with static pages, a highly instructive exercise, rich in
implications. We will get a first taste of automated testing, which
will help us be more confident that our code is correct. Moreover,
having a good test suite will allow us to /refactor/ our code with
confidence, changing its form without changing its function. 

*Sample app setup Git*. \\
The commit and push sequence below is the kind of pattern that should
be followed in real-life development.
1) git checkout -b static-pages
2) rails generate controller StaticPages home help
3) git add -A
4) git commit -m "Add a Static Pages controller"
5) git push -u origin static-pages
6) git push

*Undoing things a la Rails*. \\
Controllers
1) rails generate controller StaticPages home help
2) rails destroy controller StaticPages home help
Models
1) rails generate model User name:string email:string
2) rails destroy model User
Migrations
1) rails db:migrate
2) rails db:rollback    undo a single migration
3) rails db:migrate VERSION=0    undo to the beginning

=GET=. \\
HTTP defines the basic operations =GET=, =POST=, =PATCH=, and
=DELETE=. These refer to operations between a /client/ computer and a
/server/. An emphasis on HTTP verbs is typical of web frameworks
influenced by the /REST architecture/.
- =GET=: used for /reading/ data on the web
- =POST=: the request sent by your browser when you submit a form
- =PATCH=: updating
- =DELETE=: destroying
The last two are less common commong then =GET= and =POST= since
browsers are incapable of sending them natively, but web frameworks
(including Rails ) have clever ways of making it /seem/ like 
browsers are issuing such request.

*Killing Spring server*. \\
Spring processes sometimes accumulate and slow performance of your
tests. If tests appear sluggish, its a good idea to inspect system
process and kill them if necessary. \\
- =ps aux=: display all process on system
- =ps aux | grep spring=: display spring processes
- =kill -15 pid=: issue Unix termination signal =-15= to kill process =pid=
- =spring stop=: try stopping spring through its command
- =pkill -15 -f spring=: if =spring stop= fails, then kill all
  processes with name =spring=

*Guard*. \\
The =rails test= command requires us to switch to the command line and
run the tests by hand. We can automate this behavior with Guard. Guard
monitors the filesystem so that, for example, when we change the
=static_pages_controller_test.rb= file, only those tess get run. Even
better, we can configure Guard so that when, say, the =home.html.erb=
file is modified, the =static_pages_controller_test.rb= automatically
runs. \\
1) =bundle exec guard init= (one time setup step)
2) =bundle exec guard= automatically run tests
   1) return to run all the tests
   2) Ctrl-D to exit
* Rails-flavored Ruby
*Motivation*. \\
Ruby is a big language, but the subset needed to be productive as a
Rails developer is relatively small. This chapter is designed to give
you a solid foundation in Rails-flavored Ruby. \\

Built-in helpers. \\
From =app/views/layouts/application.html.erb= we have a line
#+BEGIN_SRC ruby
<%= stylesheet_link_tag 'application', media: 'all',
                                       'data-turbolinks-track': 'reload' %>
#+END_SRC
This uses the built-in Rails function =stylesheet_link_tag= to include
=application.css= for all media types. There are four Ruby ideas:
- built-in Rails methods
- method invocation with missing parentheses
- symbols
- hashs

Custom helpers. \\
Rails allows the cration of built-in functions called /helpers/. Its
good convention to have a /base tite/ we use on every page, with an
optional page title if we want to be more specific. In the static
pages section, if we removed the =provide(:title, "...")= we would not
yield anything to the title tag. This problem can be solved with a
helper function =full_title=.
#+BEGIN_SRC ruby
module ApplicationHelper
  # Return the full title on a per-page basis.
  def full_title(page_title='')
    base_title = "Ruby on Rails Tutorial Sample App"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end 

<title><%= full_title(yield(:title)) %></title>
#+END_SRC
The helper code above is full of Ruby ideas: modules, method
definition, optional method argument, comments, local variable
assignment, booleans, control flow, string concatenation, and return
values.

*Strings and methods*. \\
Our principal tool for learning Ruby will be the /Rails console/
(built on irb). The console is a great learning tool. 
- Ctrl-C is you get stuck
- Ctrl-D to exit the console

Strings are the most important data structure for web apps, since web
pages ultimately consist of strings of characters sent from the server
to the browser.
- string literal: "foo"
- string concat: "foo" + "bar"
- string assign: first_name = "Lupo"
- string interp: "#{first_name} Zeneli", but not '#{first_name} Zeneli'
To /print/ a string to the screen, the most commonly used Ruby
function is =puts=. The =puts= method operates as a /side-effect/: a
=puts= expression prints the argument to the screen then returns
=nil=. 
=print= prints the raw string without a newline char like =puts=. \\

Object and message passing. \\
Everything in Ruby is a an object; you have to build your intuition
for objects by seeing lots of examples. Its easier to describe what
objects do, i.e respond to messages. Messages that get passed to
objects are /methods/, which are functions defined on those
objects. \\
Ex: Strings respond to the =empty?= method. \\
=!!= coerces an object to its boolean value.

Note that Ruby functions have an /implicit return/, meaning they
return the last statement evaluated. So the following two definitions
of =string_message= are equivalent.
#+BEGIN_SRC ruby
def string_message(str='')
  if str.empty?
    "Its an empty string!"
  else
    "The string is nonempty."
  end
end

def string_message(str='')
  return "Its an empty string!" if str.empty?
  return "The string is nonempty."
#+END_SRC
The second return of the second =string_message= function is
unnecessary--being the last expression means it will be returned
regardless of the keyword =return=. In this case, we make the return
explicit for readability. \\
#+BEGIN_SRC
def palindrome_tester(s)
  if s == s.reverse
    puts "It's a palindrome!"
  else
    puts "It's not a palindrome."
  end
end
#+END_SRC

Back to title helper. \\
#+BEGIN_SRC ruby
module ApplicationHelper
  # Returns the full title on a per-page basis.       # Documentation comment
  def full_title(page_title = '')                     # Method def, optional arg
    base_title = "Ruby on Rails Tutorial Sample App"  # Variable assignment
    if page_title.empty?                              # Boolean test
      base_title                                      # Implicit return
    else
      page_title + " | " + base_title                 # String concatenation
    end
  end
end
#+END_SRC
Modules provide a way to package together related methods, which can
then be /mixed in/ to Ruby classes using =include=. When writing
ordinary Ruby, you often write modules and include them explicitly
yourself. In the case of a helper module Rails handles the inclusion
for us. The result is that the =full_title= method is available in all
our views. 

*Other data structures*. \\
Web apps are ultimately about strings, but /making/ those strings
requires other data structures as well. 

Arrays and ranges. \\
Understanding arrays provides a foundation for understanding hashes
and aspects of Rails data modeling (e.g =has_many= associations). Ruby
arrays are zero-offset. In additon to the conventional square bracket
syntax for accessing array elements, Ruby offers synonyms =first=,
=second=, and =last=. 
#+BEGIN_SRC ruby
>> # split on defualt; space 
>>  "foo bar     baz".split     # Split a string into a three-element array.
=> ["foo", "bar", "baz"]
>> # split on 'x'
>> "fooxbarxbazx".split('x')
=> ["foo", "bar", "baz"]

>> # none of the methods change the array a
>> a
=> [42, 8, 17]
>> a.empty?
=> false
>> a.include?(42)
=> true
>> a.sort
=> [8, 17, 42]
>> a.reverse
=> [17, 8, 42]
>> a.shuffle
=> [17, 42, 8]
>> a
=> [42, 8, 17]

>> # mutator methods of arrays ("bang" suffix)
>> a
=> [42, 8, 17]
>> a.sort!
=> [8, 17, 42]
>> a
=> [8, 17, 42]

>> # push operations; arrays contain mixture of types
>> a.push(6)                  # Pushing 6 onto an array
=> [42, 8, 17, 6]
>> a << 7                     # Pushing 7 onto an array
=> [42, 8, 17, 6, 7]
>> a << "foo" << "bar"        # Chaining array pushes
=> [42, 8, 17, 6, 7, "foo", "bar"]

>> # join: inverse of split
>> a
=> [42, 8, 17, 6, 7, "foo", "bar"]
>> a.join                       # Join on nothing.
=> "4281767foobar"
>> a.join(', ')                 # Join on comma-space.
=> "42, 8, 17, 6, 7, foo, bar"

>> # ranges to arrays via to_a
>> 0..9
=> 0..9
>> 0..9.to_a              # Oops, call to_a on 9.
NoMethodError: undefined method `to_a' for 9:Fixnum
>> (0..9).to_a            # Use parentheses to call to_a on the range.
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> # slicing: pulling out array elements
>> a = %w[foo bar baz quux]         # Use %w to make a string array.
=> ["foo", "bar", "baz", "quux"]
>> a[0..2]
=> ["foo", "bar", "baz"]
>> # slice to the end; -1 trick
>> a = (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..(a.length-1)]               # Explicitly use the array's length.
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..-1]                         # Use the index -1 trick.
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> # character ranges
>> ('a'..'e').to_a
=> ["a", "b", "c", "d", "e"]
#+END_SRC

Blocks. \\
Arrays and ranges respond to a host of methods that accept /blocks/.
=(1..5).each { |i| puts 2 * i }= calls the =each= method on the range
=(1..5)= and passes the block as an argument to =each=.  =|i|= is Ruby
syntax for a block varaible. In the Rails Tutorial we’ll follow the
common convention of using curly braces only for short one-line blocks
and the do..end syntax for longer one-liners and for multi-line
blocks. \\
To understand blocks, you have to see them a lot and eventually get
used to them. Below are a few examples that use the =map= method on
arrays and ranges. The =map= method returns the result of applying the
given block to each element of the array or range. 
#+BEGIN_SRC ruby
>> (1..5).each do |i|
?>   puts 2 * i
>> end
246810=> 1..5
>> (1..5).each do |number|
?>   print 2 * number
>>   print '--'
>> end
2--4--6--8--10--=> 1..5

>> 3.times { puts "Betelgeuse!" }   # 3.times takes a block with no variables.
"Betelgeuse!"
"Betelgeuse!"
"Betelgeuse!"
=> 3
>> (1..5).map { |i| i**2 }          # The ** notation is for 'power'.
=> [1, 4, 9, 16, 25]
>> %w[a b c]                        # Recall that %w makes string arrays.
=> ["a", "b", "c"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"]
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]

>> # when calling a method of the variable use "symbol-to-proc"
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]
>> %w[A B C].map(&:downcase)
=> ["a", "b", "c"]

>> # generate random subdomains
>> ('a'..'z').to_a                     # An alphabet array
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
>> ('a'..'z').to_a.shuffle             # Shuffle it.
=> ["c", "g", "l", "k", "h", "z", "s", "i", "n", "d", "y", "u", "t", "j", "q",
"b", "r", "o", "f", "e", "w", "v", "m", "a", "x", "p"]
>> ('a'..'z').to_a.shuffle[0..7]       # Pull out the first eight elements.
=> ["f", "w", "i", "a", "h", "p", "c", "x"]
>> ('a'..'z').to_a.shuffle[0..7].join  # Join them together to make one string.
=> "mznpybuj"
#+END_SRC

Hashes and symbols. \\
Hashes are indicated with curly braces containing key-value
pairs. Hashes doe not guarantee keeping elements in a particular
order. If order matters, use an array. hash value for an undefined key
is simply nil. \\
Although hashes can accept any object as a key, its more common to use
symbols. Symbols represent a single entity (rather then a set of
characters such as strings) so they are compared easily in O(1)
time. This makes them ideal as key representations. The
symbol/hashrocket construction follows the hash notation of other
languages (such as JS). =:name =>= and =name:= are effectively the
same /only inside literal hashes/. \\
Hash values can be virtually anything, even other hashes (cf. code
below). These nested hashes are heavily used by Rails. Hashes (like
ranges and arrays) respond to the =each= method (cf. code below). \\
Note. =inspect= returns a string with a literal representation of the
object it's called on.

#+BEGIN_SRC ruby
>> user = {}                          # {} is an empty hash.
=> {}
>> user["first_name"] = "Michael"     # Key "first_name", value "Michael"
=> "Michael"
>> user["last_name"] = "Hartl"        # Key "last_name", value "Hartl"
=> "Hartl"
>> user["first_name"]                 # Element access is like arrays.
=> "Michael"
>> user                               # A literal representation of the hash
=> {"last_name"=>"Hartl", "first_name"=>"Michael"}

>> # hash literal representation
>> user = { "first_name" => "Michael", "last_name" => "Hartl" }
=> {"last_name"=>"Hartl", "first_name"=>"Michael"}

>> # symbol examples
>> "name".split('')
=> ["n", "a", "m", "e"]
>> :name.split('')
NoMethodError: undefined method `split' for :name:Symbol
>> "foobar".reverse
=> "raboof"
>> :foobar.reverse
NoMethodError: undefined method `reverse' for :foobar:Symbol
>> user = { :name => "Michael Hartl", :email => "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> user[:name]              # Access the value corresponding to :name.
=> "Michael Hartl"
>> user[:password]          # Access the value of an undefined key.
=> nil

>> # symbol and hashrocket combination 
>> h1 = { :name => "Michael Hartl", :email => "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> h2 = { name: "Michael Hartl", email: "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> h1 == h2
=> true

>> # nested hashes
>> params = {}        # Define a hash called 'params' (short for 'parameters').
=> {}
>> params[:user] = { name: "Michael Hartl", email: "mhartl@example.com" }
=> {:name=>"Michael Hartl", :email=>"mhartl@example.com"}
>> params
=> {:user=>{:name=>"Michael Hartl", :email=>"mhartl@example.com"}}
>>  params[:user][:email]
=> "mhartl@example.com"

>> # each on hashes with inspect method calls
>> flash = { success: "It worked!", danger: "It failed." }
=> {:success=>"It worked!", :danger=>"It failed."}
>> flash.each do |key, value|
?>   puts "Key #{key.inspect} has value #{value.inspect}"
>> end
Key :success has value "It worked!"
Key :danger has value "It failed."

>> # more inspect calls
>> puts (1..5).to_a            # Put an array as a string.
1
2
3
4
5
>> puts (1..5).to_a.inspect    # Put a literal array.
[1, 2, 3, 4, 5]
>> puts :name, :name.inspect
name
:name
>> puts "It worked!", "It worked!".inspect
It worked!
"It worked!"

>> # inspect shortcut
p :name             # Same output as 'puts :name.inspect'
:name
#+END_SRC

CSS revisited. \\
In Ruby, parentheses are optional during function calls. When hashes
are the /last/ argument in a function call, the curly braces are
optional. Ruby interprets it correctly because, Ruby doesn't
distinguish between newlines and other whitespace in this
context. Breaking the lines with whitespace helps in readability. \\
The =stylesheet_link_tag= function is called with two arguments:
- a string indicating the path to the stylesheet
- a hash with two elements, indicating the media type and telling
  Rails to use the turbolinks feature
Because of the ERb, the results are inserted into the template of the
ERb. 

#+BEGIN_SRC ruby
# Parentheses on function calls are optional.
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')
stylesheet_link_tag 'application', media: 'all',
                                   'data-turbolinks-track': 'reload'
# Curly braces on final hash arguments are optional.
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }
#+END_SRC

*Ruby classes*. \\
Ruby uses /classes/ to organize methods; these classes are than
/instantiated/ to create objects. \\
Constructors. We instantiated a string using the double quote
characters, i.e a literal constructor for strings. But we can also use
the =new= keyword on the class name itself to instantiate an
object. Arrays work the same way; they accept a literal array. Hashes,
in contrast to =Array.new=, take a default value for the hash, which
will be the value for nonexistent keys. \\
When a method gets called on the class itslef (e.g =new=), then it is
a /class method/. A method call on an instance (e.g. =length= on an
array) is an /instance method/.  
#+BEGIN_SRC ruby
>> s = String.new("foobar")   # A named constructor for a string
=> "foobar"
>> s.class
=> String
>> s == "foobar"
=> true
>> a = Array.new([1, 3, 2])
=> [1, 3, 2]
>> h = Hash.new
=> {}
>> h[:foo]            # Try to access the value for the nonexistent key :foo.
=> nil
>> h = Hash.new(0)    # Arrange for nonexistent keys to return 0 instead of nil.
=> {}
>> h[:foo]
=> 0
#+END_SRC

Class inheritance. \\
The =class= and =superclass= methods are useful to find out the class
hierarchy. If you trace back the class hierarchy far enough then every
class in Ruby ultimately inherits from =BasicObject=, which has no
superclass itself. This is the technical meaning of "everything in
Ruby is an object". 
#+BEGIN_SRC ruby
>> s = String.new("foobar")
=> "foobar"
>> s.class                        # Find the class of s.
=> String
>> s.class.superclass             # Find the superclass of String.
=> Object
>> s.class.superclass.superclass  # Ruby 1.9 uses a new BasicObject base class
=> BasicObject
>> s.class.superclass.superclass.superclass
=> nil

>> class Word < String             # Word inherits from String.
>>   # Returns true if the string is its own reverse.
>>   def palindrome?
>>     self == self.reverse        # self is the string itself.
>>   end
>> end
=> nil
>> s = Word.new("level")    # Make a new Word, initialized with "level".
=> "level"
>> s.palindrome?            # Words have the palindrome? method.
=> true
>> s.length                 # Words also inherit all the normal string methods.
=> 5
>> s.class
=> Word
>> s.class.superclass
=> String
>> s.class.superclass.superclass
=> Object
#+END_SRC

Modify built-in classes. \\
While inheritance is a powerful idea, in the case of palindrome it
might be more natural to add the =palindrome?= method to the =String=
class itself, so we can use it on a string literal. Modifying built-in
classes is a powerful technique, but its considered bad form to add
methods to built-in classes without having a /really good/ reason for
doing so. \\
In Rails, web apps often want to prevent variables from being
blank--e.g a user's name should be something other than whitespace, so
rails adds the =blank?= method to Ruby. \\
The =self= keyword does not need to be used when dealing with
classes. =self= may be removed and all method calls in the function
weill be done on the instance. 
#+BEGIN_SRC ruby
>> "level".palindrome?
NoMethodError: undefined method `palindrome?' for "level":String
>> class String
>>   # Returns true if the string is its own reverse.
>>   def palindrome?
>>     self == self.reverse
>>   end
>> end
=> nil
>> "deified".palindrome?
=> true

>> # Rails adds the blank? method to Ruby
>> "".blank?
=> true
>> "      ".empty?
=> false
>> "      ".blank?
=> true
>> nil.blank?
=> true
>> nil.empty?
NoMethodError: undefined method `empty?' for nil:NilClass

>> class String
>>   def shuffle
>>     self.split('').d=shuffle.join
>>   end
>> end
>> "foobar".shuffle
=> "borafo"

>> # is the same as 
>> class String
>>   def shuffle
>>     split('').shuffle.join
>>   end
>> end
>> "foobar".shuffle
=> "borafo"
#+END_SRC

A controller class. \\
When call the =home= method on the instantiated
=StaticPagesController= object, we get a value of nil. The point of
the =home= action is to render a web page, not to return a
value. Rails is written in Ruby, but Rails is not Ruby. Some Rails
classes are used like ordinary Ruby objects. Rails is its own thing
and should be studied seperately from Ruby.
#+BEGIN_SRC ruby
>> controller = StaticPagesController.new
=> #<StaticPagesController:0x22855d0>
>> controller.class
=> StaticPagesController
>> controller.class.superclass
=> ApplicationController
>> controller.class.superclass.superclass
=> ActionController::Base
>> controller.class.superclass.superclass.superclass
=> ActionController::Metal
>> controller.class.superclass.superclass.superclass.superclass
=> AbstractController::Base
>> controller.class.superclass.superclass.superclass.superclass.superclass
=> Object

>> controller.home
=> nil
#+END_SRC

A user class. \\
In Rails, the principal importance of instance variables is that they
are automatically available in the views. \\
In general they are used for variables that need to be available
throughout a Ruby class. \\
Initializing objects using a hash argument is a technique known as
/mass assignment/ (cf ch7). 
- =attr_accessor= creates /attribute accessors/ corresponding to a
  user's name and email address. This creates "getter" and "setter"
  methods that allow us to retrieve (get) and assing (set) =@name= and
  =@email= instance variables.
- =def initialize= is special in Ruby: it's the method called when we
  execute =User.new=.
- =attributes = {}=: the attributes variable has a /default value/ equal to
  the empty hash, so that we can define a user with no name or email
  address.
  - Recall: hashes return =nil= for nonexistent keys, so
    =attributes[:name]= will be =nil= and =attributes[:email]= will be
    =nil=.
#+BEGIN_SRC ruby
class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end

  def formatted_email
    "#{@name} <#{@email}>"
  end
end

>> require './example_user'     # This is how you load the example_user code.
=> true
>> example = User.new
=> #<User:0x224ceec @email=nil, @name=nil>
>> example.name                 # nil since attributes[:name] is nil
=> nil
>> example.name = "Example User"           # Assign a non-nil name
=> "Example User"
>> example.email = "user@example.com"      # and a non-nil email address
=> "user@example.com"
>> example.formatted_email
=> "Example User <user@example.com>"

>> # we can omit the curly braces for final hash arguments
>> user = User.new(name: "Michael Hartl", email: "mhartl@example.com")
=> #<User:0x225167c @email="mhartl@example.com", @name="Michael Hartl">
>> user.formatted_email
=> "Michael Hartl <mhartl@example.com>"
#+END_SRC
* Filling in the layout
Objectives:
- fill in the custom stylesheet
- fill in layout with links to the pages (such as Home and About)
- learn about partials, Rails routes, asset pipeline, and Sass
- user sign up functionality
Most of the changes deal with add/editing markup of the sample apps
layout, which (based on our testing guidelines) is exactly the kind of
work that we wouldn't ordinarily test-drive, or even test at all. Most
of the time will be in the editor and browser. We will write our first
/integration test/ to check the links on the final layout are
correct. 

*Adding some structure*. \\
We use CSS, Bootstrap, and partials to create a tidy layout. Its
useful to get a high-level overview of the UI as early as possible;
for that we use /mockups/ (in context of webapps: /wireframes), which
are rough sketches of what the eventual app will look like. \\


*Sass and the asset pipeline*. \\
The /asset pipeline/ simplifies the production and management of
static assets. 

The asset pipeline. \\
From the perspective of a typical Rails developer, there are three
main features to understand about the asset pipeline:
- asset directories: three standard directories for static
  assets. Each of these directories has a subdirectory for each asset
  class: images, JS, CSS.
  - =app/assets=: assets specific to the present app
  - =lib/assets=: assets for libraries written by our developer team
  - =vendor/assets=: assets from third party developers
- manifest files: after placing the assets in their logical locations,
  manifest files tell Rails (via Sprockets gem) how to combine them to
  form a single file. We won't need to make any changes, but see the
  Rails Guides entry on the asset pipeline for more details. Consider
  the =application.css= as an   example. The CSS comments are used by
  Sprockets to include the proper files:
  - '*= require_tree': ensures that all CSS files in the
    =app/assets/stylesheets= dir (including tree subdirs) are included
    in the application CSS.
  - '*= require_self': specifies where in the loading sequence the CSS
    in =application.css= itself gets included. 
- preprocessor engines: after you assembled your assets, Rails
  prepares them for the site template by running them through several
  preprocessing engines and using the manifest files to combine them
  for delivery to the browser. We tell Rails which processor to use
  using the filename extensions =.scss=,  =.coffee=, or =.erb=. The
  preprocessor engines can be chained, so that =foobar.js.erb.coffee=
  get run through both CoffeeScript and ERb (code from right to left).

Efficiency in production. \\
The asset pipeline results in assets that are optimized to be
efficient in a production application. Traditional methods for
organizing CSS and JS involve splitting functionality into seperate
files and using nice formatting (convenient for programmers,
inefficient for production). In particular, multiple full-sized files
can significantly slow page-load times. With the asset pipeline, we
don't have to choose between speed and convenience: we can work with
multiple nicely formated files in dev, and then use the asset pipeline
to make efficient files in production. In particular the asset
pipeline combines all the: 
- application stylesheets into one CSS file (=application.css=),
- application JS into one JS file (=application.js=),
and then minifies them to remove the unnecessary spacing and
indentation that bloats the file size.

Syntactically awesome stylesheets. \\
Sass is a language for writing stylesheets that improves on CSS. We
cover two improvements:
- nesting: nested elements can inherit from enclosing parent
  element. To reference the parent element (e.g =#logo= on hover),
  we use an =&= (cf. below) to get =&:hover= (converted by SCSS to
  =#logo:hover=). 
- variables: eliminate duplication and write more expressive code. Its
  often useful to define variables even for values that aren't
  repeated. 
- mixins (cf. ch7)
Sass supports a format called SCSS, which is a superset of CSS
itself. Consequently, every CSS file is also a valid SCSS file, which
is convenient for projects with existing style rules. Since the Rails
asset pipeline automatically uses Sass to process files with the
=.scss= extension, the =custom.scss= file will be run through the Sass
preprocessor before being packaged up for delivery to the browser. 

SCSS nesting examples.
#+BEGIN_SRC css
// CSS
.center {
  text-align: center;
}
.center h1 {
  margin-bottom: 10px;
}

// CSS hover attribute
#logo {
  ...
}
#logo:hover {
  ...
}


// SCSS
.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

// SCSS hover attribute
#logo {
  ...
  &:hover {
    ...
  }
}
#+END_SRC

SCSS variable declaration examples.
#+BEGIN_SRC css
// CSS: multiple declarations of the same attributes
h2 {
  ...
  color: #777;
}
...
footer {
  ...
  color: #777;
}

// SCSS: defining variables
$light-gray: #777;
...
h2 {
  ...
  color: $light-gray;
}
...
footer {
  ...
  color: $light-gray;
}
#+END_SRC


Rails routes. \\
To add the named routes for the sample app's static pages, we'll edit
the routes file, =config/routes.rb=, that Rails uses to define URL
mappings. We'll begin by reviewing the route for the Home page, which
is a special case, and then define a set of routes for the remaining
static pages. Root route definition (controller#action) :
 : root 'static_pages#home'
Defining the root route creates a named route that allows us to refer
to routes by names other than the raw URL. 
- =root_path= -> '/'
- =root_url=  -> 'http://www.example.com'
We use =_path= for all but redirects, in which case, we use =_url= as
specified in the HTTP standard. We redefine the verbose
=static_pages/...= routes to shorter ones:
 : get 'static_pages/help'
 : get '/help', to: 'static_pages#help'


Using named routes. \\

Layout link tests. \\
After filling several of the layout links, it's a good idea to test
them to make sure they're working correctly. We could do this by hand
with a browser: visit the root path then check the links by hand.
This quickly becomes combersome. Instead, we simulate the same series
of steps using an /integration test/.
=$ rails generate integration_test site_layout=
Our plan for testing the layout links involves checking the HTML
structure of our site:
1) get the root path (Home page)
2) verify the right page template is rendered
3) check for the correct link to the Home, Help, About, and Contact
   pages
Below we use some of the more advanced options of the =assert_select=
method. We use the syntax that allows us to test for the presence of a
particular link-URL combination by specifying the tag name =a= and
attribute =href=. Rails automatically inserts the value of (say) the
=about_path= in place of the question (escaping special characters) to
get the tag <a href"/about">...</a>. The assertion of the root path
verifies there are two such links (the logo and navigation menu
element). \\
Below are more uses of =assert_select=. While =assert_select= is flexible
and powerful (having many more options than shown here), experience
shows that it's wise to take a lightweight approach to testing only
HTML elements (such as site layout links) that are unlikely to change
much over time. 
#+BEGIN_SRC ruby
  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
  end
#+END_SRC
| Code                                        | Matching HTML                  |
|---------------------------------------------+--------------------------------|
| assert_select "div"                         | <div>foobar</div>              |
| assert_select "div", "foobar"               | <div>foobar</div>              |
| assert_select "div.nav"                     | <div class="nav">foobar</div>  |
| assert_select "div#profile"                 | <div id="profile">foobar</div> |
| assert_select "div[name=yo]"                | <div name="yo">hey</div>       |
| assert_select "a[href=?]", '/', count: 1    | <a href="/">foo</a>            |
| assert_select "a[href=?]", '/', text: "foo" | <a href="/">foo</a>            |


*User signup: a first step*. \\
We will make a route for the singup page and create a second
controller. There are three steps for representing users on the sample
app site:
1) layout and routing of the signup page (here)
2) modeling users (ch6)
3) user registration and account activation (ch7)

User controller. \\
 : $ rails generate controller Users new
We =generate= the simplest controller that meets our needs, viz one
with a stub signup page for new users. Following REST, we'll call the
action for new users =new=. \\
The result creates a Users controller with a =new= action, a stub for
a user view, a minimal test for the new user page, and the routing. 

On multiple assertions in single test. \\
Some developers insist that a single test shouldn’t contain multiple
assertions. I find this practice to be unnecessarily complicated,
while also incurring an extra overhead if there are common setup tasks
needed before each test. In addition, a well-written test tells a
coherent story, and breaking it up into individual pieces disrupts the
narrative. I thus have a strong preference for including multiple
assertions in a test, relying on Ruby (via minitest) to tell me the
exact lines of any failed assertions. 

What we learned in this chapter
- Using HTML5, we can define a site layout with logo, header, footer, and main body content.
- Rails partials are used to place markup in a separate file for convenience.
- CSS allows us to style the site layout based on CSS classes and ids.
- The Bootstrap framework makes it easy to make a nicely designed site quickly.
- Sass and the asset pipeline allow us to eliminate duplication in our CSS while packaging up the results efficiently for production.
- Rails allows us to define custom routing rules, thereby providing named routes.
- Integration tests effectively simulate a browser clicking from page to page. 
* Modeling users
- we create a /data model/ for users of our site, together with a way
  to store that data
- ch7- give users the ability to sign up for our site and create a
  user and profile page
- ch8 and ch9- let them log in and log out as well
- ch10- protect pages from improper access
- ch11 and ch12- add account activations (thereby confirming valid
  email) and password resets

Rolling our own authentication system. \\
Virtually all web apps require a login and authentication system of
some sort. Most web frameworks (Rails included) have a plethora of
authentication and authorization systems (Clearance, Authlogic,
Device, CanCan and non-Rails-specific solutions built on OpenID or
OAuth). Why reinvent the wheel? \\
Authentication on most sites requires extensive
customization. Mofifying a third-party product is often more work than
writing the system from scratch. Also, off-the-shelf systems can be
"black boxes". Writing our own helps us understand (and provides the
ability to modify) the internals of others.

*User model*. \\
Although ultimate goal is to create a signup page for our site. Before
we accept information from users, we must create data structures to
capture and store it. \\
We are dealing with the M in MVC. The default Rails solution the
problem of persistence is to use a /database/ for long-term data
storage. The default library for interacting with the database is
/Active Record/. Active Record comes with a host of methods for
creating, saving, and finding data objects, all without having to use
the structured query language SQL. \\
Moreover, Rails has a feature called /migrations/ to allow data
definitions to be written in pure Ruby, without having to learn an SQL
DDL. In effect, Rails insulates you almost entirely from the details
of the database.

Database migrations. \\
Recall: we created a custom-built =User= class and created user
objects through the Rails console. That class served as a useful
example, but lacked the critical property of /persistence/: when we
created a User object it disappeared as soon as we exited the Rails
console. Our goal is to create a model to persist users data. \\
When using Rails to model users we don't need to identify the
attributes explicitly (Rails uses a RDB by default). 
 : We generated a Users controller with:
 : $ rails generate controller Users new
 : To generate a model, we use the analogous command
 : $ rails generate model User name:string email:string
Note. In contrast to the plural convention for controller names,
models names are singular: a Users controller, but a User model. \\
The result of the model generator is a migration file. Migrations
provide a means to alter the structure of the RDB incrementally. \\
The migration consists of a =change= method that determines the change
to be made to the database. The =create_table= method accepts a block
with one block variable, in this case called =t= for table. Inside the
block, the =create_table= method uses the =t= object to create =name=
and =email= columns in the database, both of type string. Here the
table name is plural, =users=, even though the model name is singular
=User=, reflecting the linguistic convention followed by Rails: 
- a model represents a single user
- a database table consists of many users.
=t.timestamps= creates two colums, =created_at= and =updated_at=,
which are timestamps for the record. \\
We run =rails db:migrate= to 'migrate up'. The first time its run, it
creates a file =db/development.sqlite3=, which is an SQLite
database. \\
Under the hood, this command executes the =drop_table= command to remove
the users table from the database. The reason this works is that the
change method knows that =drop_table= is the inverse of =create_table=,
which means that the rollback migration can be easily inferred. In the
case of an irreversible migration, such as one to remove a database
column, it is necessary to define separate up and down methods in
place of the single change method. Read about migrations in the Rails
Guides for more information.
#+BEGIN_SRC ruby
def change
    create_table :users do |t|
      t.string :name
      t.string :email

      t.timestamps
    end
#+END_SRC


Creating user objects. \\
=rails console --sandbox= for when we don't want to make any
changes. An class inheriting from Active Record also takes an
initialization hash to set the object attributes:
 : >> user = User.new(name: "Lupo Zen", email: "lzen@example.com")
 : => #<User id: nil, name: "Lupo Zen", email: "lzen@example.com", 
        created_at: nil, updated_at: nil>
 : >> user.valid?
 : true
Our =user= object is valid, as verified by calling the =valid?=
method (cf. below). So far we've only created the object in memory
(note the =id= column). We can use the =save= method to persist
objects from memory to the database. You can learn a lot by reading
by reading the SQL corresponding to Active Record commands. \\
The =create= method combins the =new= and =save= method to directly
persist. While =save= returns a boolean to determine if the user was
saved, =create= simply returns the user object back. The inverse is
the =destroy= method which also returns the object in question. The
destroyed object still exists in memory. \\
So how do we know if we really destroyed an object? And for saved and
non-destroyed objects, how can we retrieve users from the database? We
need to learn how to use Active Record to find user objects. 
#+BEGIN_SRC ruby
>> user.save
(0.4ms)  SAVEPOINT active_record_1
  SQL (0.8ms)  INSERT INTO "users" 
  ("name", "email", "created_at", "updated_at") 
  VALUES ($1, $2, $3, $4) RETURNING "id"  
  [["name", "Lupo Zen"], ["email", "lzen@example.com"], 
  ["created_at", 2016-08-19 23:43:33 UTC], 
  ["updated_at", 2016-08-19 23:43:33 UTC]]
   (0.3ms)  RELEASE SAVEPOINT active_record_1
=> true
>> user
=> #<User id: 1, name: "Lupo Zen", email: "lzen@example.com", 
  created_at: "2016-08-19 23:43:33", updated_at: "2016-08-19 23:43:33">
#+END_SRC

Finding user objects. \\
- =User.find(1)=: matches the id field of user records. 
- =User.find_by(email: "...")=: match specified column with
  specified paramter of a user record.
- =User.first= : first user of the database.
- =User.all= : returns all the users in the database as an object of
  class =ActiveRecord::Relation= (effectively an array).
- =user.reload= : reloads that in memory =user= object from the
  database copy. We can change the in memory copy and persist with
  =save=. In effect, reassigning is a way to update multiple attributes.
- =user.update_attributes(name: "...")= a second way to update
  multiple attributes. Returns boolean as sentinel value.

Updating user objects. \\
Once we've create objects, we often want to update them. There are two
basic ways to do this.
- =save=: we can assign attributes individually, then =save=, then
  =reload= from the database to see the affected attributes (as well
  as the =user.updated_at= attribute).
- =update_attributes=: the method accepts a hash of attributes, and on
  success performs both the update and save in one step (returning
  =true= to indicate that the save went through). Note- If any of the
  validation fails, such as when a password is required to save a
  record, the call to =update_attributes= will fail. We use the
  singular to bypass this restriction.
#+BEGIN_SRC ruby
assignment then save
>> user           # Just a reminder about our user's attributes
=> #<User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58">
>> user.email = "mhartl@example.net"
=> "mhartl@example.net"
>> user.save
=> true
reload from the database
>> user.email
=> "mhartl@example.net"
>> user.email = "foo@bar.com"
=> "foo@bar.com"
>> user.reload.email
=> "mhartl@example.net

update attribute method call
>> user.update_attribute(:name, "El Duderino")
=> true
>> user.name
=> "El Duderino"
#+END_SRC

*User validations*. \\
The User model now has working =name= and =email= attributes, but they
are completely generic; any string will do. We will add validations
for =name= not to be blank, =email= should match the specific format
characteristic of email addresses. Moreover, since we'll be using
email addresses as unique usernames when users log in, we shouldn't
allow email duplicates in the database. \\
Active Record allows us to impose contraints on fields values using
/validations/. We cover the most common cases, validating /presence/,
/length/, /format/ and /uniqueness/. Later we cover /confirmation/. In
ch7 we'll see how validations give us convenient error messages when
users make submissions that violate them. 

A validity test. \\
Model validation is a perfect fit for TDD. It's difficult to be
confident that a given validation is doing exactly what we expec it to
without writing a failing test and then getting it to pass. \\
Our method:
- start with a /valid/ model object,
- set one of its attributes to something we want to be invalid,
- and test that it in fact is invalid.
As a safety net, we'll first write a test to make sure the initial
model object is valid. This way, when the validation tests fail we'll
know it's for the right reason (and not bc the initial object was
invalid in the first place). \\
To write a test for a valid object, we'll create an initially valid
User model object =@user= using the special =setup= method which
automatically gets run before each test. Bc =@user= is an instance
variable, it's automatically available in all the tests, and we can
test its validity using the =valid?= method. The =assert= method
succeeds if =@user.valid?= returns =true= and fails on =false=. \\
Since the =User= class has no =validates= methods, the model is
valid. 
#+BEGIN_SRC ruby
def setup
  @user = User.new(...)
end
test "should be valid" do
  assert @user.valid?
end
#+END_SRC

Validity presence. \\
/Presence/ simply verifies that a given attribute is present. We start
with a test for the presence of a =name= attribute:
- set the =@user= variable's =name= to a blank string
- check (via =assert_not=) that the resulting User object is not
  valid.
 : test "name should be present" do
 :   @user.name = "     "
 :   assert_not @user.valid?
 : end
Running =$ rails test:models= yields RED (failing). This is the
behavior we expect our model to follow, given a blank name, the
statement "assert that the model is not valid" should be true. We
augment the model object to make the statement true:
 : class User < ApplicationRecord
 :   validates :name, presence: true
 : end
Not only do the tests yield GREEN (pass), but we can also see this in
action using =$ rails console --sandbox=. Trying to save a model with
a blank no longer shows the SQL query, rather it displays a red
=ROLLBACK TO SAVEPOINT=. \\
=errors= displays the address of any associated errors with the
model. =errors.full_messages= displays the errors array with the
values of the errors. 

Same process should be followed for validating the presence of the
email attribute of the User model:
- write test statement for expected behavior (via =assert_not=) in the
  =UserTest=
 : test "email should be present" do
 :   @user.email = "     "
 :   assert_not @user.valid?
 : end
- run the test, see it fail (RED): =$ rails test:models=
- augment the model with intentions of providing expected behavior:
  =validates :email, presence: true=
- run the test, see it pass (GREEN): =$ rails test:models=

Length validation. \\
The user’s names will be displayed on the sample site, so we should
enforce some limit on their length.
 : test "name should not be long" do
 :   @user.name = "a" * 51  # over 50 is considered long
 :   assert_not @user.valid?
 : end
This test fails since the user has no length validation. We add length
validation to the user model:
 : validates :name, presence: true, length: { maximum: 50 }
=$ rails test:models= yields GREEN. 

Format validation. \\
The =email= attribute must satisfy more stringent requirements of
being a valid email address. So far, we've only reject blank email
addresses. Here, we require the email to conform to the familiar
pattern =user@example.com=. \\
Neither the test nor the validation will be exhaustive, just good
enough to accept most email addresses and reject most invaild
ones. Recall: the tests specify the behavior we expect. So the test
with the valid addresses are examples of what we expect to be valid
emails. The tests with invalid email address are examples of what we
expect to be invalid. We augment the model with the email validation
code that makes both these examples pass. In a way, we are defining
the boundary conditions of the correct and incorrect behavior of the
model, then implementing the least amount of functionality to make
these assertions examples pass.  \\
Bc email format validation is tricky and error-prone, we'll start with
passing tests for /valid/ email addresses to catch any errors in the
validation. \\
Remark: we can create an array of strings using the =%w[...]=
construct.Below we use =assert= with the second, optional, parameter as our
custom message. Recall: the interpolated =inspect= method returns the
value of the objects =to_s= method.
#+BEGIN_SRC ruby
test "email validation should accept valid addresses" do
  valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org
                       first.last@foo.jp alice+bob@baz.cn]
  valid_addresses.each do |valid_address|
    @user.email = valid_address
    assert @user.valid?, "#{valid_address.inspect} should be valid"
  end
end
test "email validation should not accept invalid addresses" do
  invalid_addresses = %w[user@example,com user_at_foo.org 
              user.name@example. foo@bar_baz.com foo@bar+baz.com ]
  invalid_addresses.each do |invalid_address|
    @user.email = invalid_address
    assert_not @user.valid? , "#{invalid_address.inspect} should be invalid"
  end
end
#+END_SRC
The application code for the email format validation uses the =format=
validation, which works like this: =validates :email, format: { with:
/<regexp>/ }=. Regular expressions are uses for matching patterns in
strings. Here, we use it to match valid email addresses while not
matching invalid ones. There exists a [[http://emailregex.com][full regex]] for matching email
addresses according to the [[http://www.ietf.org/rfc/rfc5322.txt][official email standard]], but it's enormous,
obscure, and possibly counter-productive. We'll adopt a pragmatic
regex that has proven to be robust in practice (see [[http://www.rubular.com/r/aE4zppL0TA][rublar]] leave off
the \A and \z characters so that you can match more than one email
address at a time in the given test string) : 
 : VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
| Expression                           | Meaning                                           |
| /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i | full regex                                        |
| /                                    | start of regex                                    |
| \A                                   | match start of a string                           |
| [\w+\-.]+                            | at least one word character, plus, hyphen, or dot |
| @                                    | literal “at sign”                                 |
| [a-z\d\-.]+                          | at least one letter, digit, hyphen, or dot        |
| \.                                   | literal dot                                       |
| [a-z]+                               | at least one letter                               |
| \z                                   | match end of a string                             |
| /                                    | end of regex                                      |
| i                                    | case-insensitive                                  |
Applying the regex to the =email= format validation yields:
: validates :email, presence: true, length: { maximum: 255 }, 
:                   format: { with: VALID_EMAIL_REGEX }
The regex =VALID_EMAIL_REGEX= is a /constant/, idicated in Ruby by a
name starting with a capital letter. 
Note: the regex above allows multiple dots like =foo@bar..com=. The
following is a fix: =VALID_EMAIL_REGEX =
/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i=. 

Uniqueness validation. \\
To enforce uniqueness of email addresses (so that we can use them as
usernames), we'll be using the =:unique= option in the =validates=
method. We start with some tests. We cannot use =User.new= as before,
this behavior requires persisting to the database to ensure uniquess
at the persistence level. \\
We specify that the behavior of saving two users with the same email
should not be valid (via the =dup= method). 
#+BEGIN_SRC ruby
  test "email addresses should be unique" do
    duplicate_user = @user.dup
    @user.save
    assert_not duplicate_user.valid?
  end
#+END_SRC
Adding =uniqueness: true= to the User email =validates= method yields
the desired GREEN. \\
Email addresses are typically processed as if they were
case-insensitive--i.e,=foo@bar.com= is the same as =FOO@BAR.COM= or
=FoO@BAr.coM=-- so our validation should incorporate this as
well. Adding the following line to our email unique example test
yields a failing test:
 : duplicate_user.email = @user.email.upcase
If this test feels a little abstract, go ahead and fire up the
console:
#+BEGIN_SRC ruby
$ rails console --sandbox
>> user = User.create(name: "Example User", email: "user@example.com")
>> user.email.upcase
=> "USER@EXAMPLE.COM"
>> duplicate_user = user.dup
>> duplicate_user.email = user.email.upcase
>> duplicate_user.valid?
=> true
#+END_SRC
Hence the test is RED. =uniqueness= accepts an option:
=case_sensitive: false=. This yields the desired GREEN. 
Problem: Active Record uniqueness validation does not guarantee
uniqueness at the database level. 
Consider the scenario:
1) Alice uses =alice@wonderland.com=
2) Alice clicks 'Submit' twice, sending two quick requests
3) Requests pass validation in memory, so both are persisted:
   1) Request 1 creates a user in memory that passes validation
   2) Request 2 does the same and also pases validation
   3) Request 1's user gets saved
   4) Request 2's user gets saved
4) Result: two user records with the same email despite the uniqueness
   validation
Solution: enforce uniqueness at the database level as well as the
model level. Our method: create a database /index/ on the email column
and require that index to be unique. \\
Dealing with the database level requires migrations:
 : $ rails generate migration add_index_to_users_email
Unlike the users migration, the
=[timestamp]_add_index_to_users_email.rb= migration is not
pre-defined, so we fill in its contents: 
 : class AddIndexToUsersEmail < ActiveRecord::Migration[5.0]
 :   def change
 :     add_index :users, :email, unique: true
 :   end
 : end
We migrate the database =$ rails db:migrate=. (If this fails, try
exiting any running sandbox console sessions, which can lock the
database and prevent migrations.)
Remark: an alternative to generating a new migration is to add these
changes to the =users= =change= method. This requires rolling back
then migrating up. \\
Note. The Rails Way is to use migrations every time we discover that
our data model needs to change. \\
#+TODO implement this scenrio when learning ruby threads
Already attempted this using Ruby multi-assignement
#+BEGIN_SRC ruby
 alice = User.new(name: "Alice", email: "alice@wonderland.com")
 => #<User id: nil, name: "Alice", email: "alice@wonderland.com", 
    created_at: nil, updated_at: nil> 
2.3.1 :009 > alice2 = alice.dup
 => #<User id: nil, name: "Alice", email: "alice@wonderland.com", 
    created_at: nil, updated_at: nil> 
2.3.1 :010 > r1, r2 = alice.save, alice2.save
   (0.2ms)  SAVEPOINT active_record_1
  User Exists (0.4ms)  SELECT  1 AS one FROM "users" 
    WHERE "users"."email" = $1 LIMIT $2  [["email", "alice@wonderland.com"],
     ["LIMIT", 1]]
  SQL (0.3ms)  INSERT INTO "users" ("name", "email", 
    "created_at", "updated_at") VALUES ($1, $2, $3, $4) 
    RETURNING "id"  [["name", "Alice"], ["email", "alice@wonderland.com"], 
    ["created_at", 2016-08-21 21:17:13 UTC], 
    ["updated_at", 2016-08-21 21:17:13 UTC]]
   (0.1ms)  RELEASE SAVEPOINT active_record_1
   (0.1ms)  SAVEPOINT active_record_1
  User Exists (0.2ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" =
     $1 LIMIT $2  [["email", "alice@wonderland.com"], ["LIMIT", 1]]
   (0.1ms)  ROLLBACK TO SAVEPOINT active_record_1
 => [true, false] 
2.3.1 :011 > r1, r2 = alice.valid?, alice2.valid?
  User Exists (0.6ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" =
     $1 AND ("users"."id" != $2) LIMIT $3  [["email", "alice@wonderland.com"], 
    ["id", 2], ["LIMIT", 1]]
  User Exists (0.3ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" = 
    $1 LIMIT $2  [["email", "alice@wonderland.com"], ["LIMIT", 1]]
 => [true, false] 
#+END_SRC


Database indices. \\
When creating a column in a database, it's important to consider if we
need to /find/ records by that column. For example, when we allow
users to log in the sample app, we need to find the corresponding user
to the submitted email address. With the current data model, we must
do a linear search (key being the email requested) through all the
users of the database-- i.e a /full-table/ scan. 
Providing an inedex on the email column fixes the problem.

After migrating. The test suite is RED due to violation of the
uniqueness constraint in the /fixtures/, which contain sample data for
the test database. Fixture data doesn't run through validations so
they did not fail earlier tests. They are persisted in the test
database and bc they have the same email, all tests fail. 
#+BEGIN_SRC ruby
one:
  name: MyString
  email: MyString

two:
  name: MyString
  email: MyString
#+END_SRC
Simply removing the contents of the file passes the tests. 

Some databases use case-sensitive indices, but our app treats them the
same. To avoid this incompatibility, we'll standardize on all
lower-case addresses using a =before_save= callback in the =User= model. 
 : before_save { self.email = email.downcase }
At this point, the Alice scenario above will work fine. 

*Adding a secure password*. \\
Method: require each user to have a password (w/ password
confirmation), then store a /hashed/ version in the database. We add a
way to /authenticate/ a user based on a given password (cf. ch8) to
allow users to log in to the site.  Here a /hash/ refers to the result
of applying an irreversible hash function to input data. \\
Authenticating users :
1) take a submitted password
2) hash it
3) compare the result to the hashed value stored in the database
4) if the two match, then submitted password is correct (user authenticated)
By comparing hashed values instead of raw passwords, we will be able to
authenticate users without storing the raw passwords themeselves. Even
if our database is compromised, our users' passwords will still be
secure.

A hashed password. \\
Most of the secure password machinery will be implemented using a
single Rails method =has_secure_password=. When included, it adds:
- ability to save securely hashed =password_digest= attribute to db
- pair of virtual attributes (=password= & =password_confirmation=)
- =authenticate= method that returns the user when password is correct
The model must have a =password_digest= attribute (synonymous with
hashed password). \\
To add the =password_digest= attribute to the =User= model we must
create a migration: =$ rails g migration add_password_digest_to_users
password_digest:string=. Then migrate up. \\
To make the password digest, =has_secure_password= uses a bcrypt (via
the bcrypt gem).

User has secure password. \\
After adding the =has_secure_password= (see
[[http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password][ActiveModel::SecurePassword::ClassMethods)]] to the User model and
running the tests, we see RED on the tests that assert validity of the
=@user= from setup. All other tests using =assert_not= remain passing
since the model remains invalid but now for the wrong reasons (like test
"name should be present"). =has_secure_password= enforces validation
on the virtual =password= and =password_confirmation= attributes, but
the tests create a =@user= variable w/out these attributes. \\
Resulting =test/models/user_test.rb= is:
:  def setup   # create a valid user
:    @user = User.new(name: "Example User", email: "user@example.com",
:                     password: "foobar", password_confirmation: "foobar")
:  end

Minimum password standards. \\
Good practice: enforce minimum standards on passwords (harder to
guess). Password validations: minimum length of 6 and non blank
results in the following added tests. \\
Aside: tests are documentation. They should explicitly denote what
functionality they are testing. Consider test "name should not be too
long". The evident assignment of 51 chars is considered to long (as
opposed to 51 literal, different chars) is clear to the reader. The
name itself implies the behavior.
 : test "name should not be too long" do
 :   @user.name = "a" *51
 :   assert_not @user.valid?

Creating and authenticating a user. \\
Since users can't sign up through the web (goal in ch7), we use the
=create= method.

*Conclusion*. \\
Starting from scratch, we have a User model w/ name, email, and
password attributes w/ enforcing validations). We have the ability to
securely authenicate users using a given password (all in twelve lines
of code). \\
In ch7, we make a working signup form to create new users w/ a page
displaying each users information. 

What we learned in this chapter. \\
- migrations allow us to modify our application's data model
- active record comes w/ a large number of methods for creating and
  manipulating data models
- active record validations allow us to place constraints on the data
  in our models
- common validations include presence, length, and format
- regular expressions are cryptic but powerful
- defining a database index improves lookup efficiency while allowing
  enforcement of uniqueness at the database level
- we can add a secure password to a model using the built-in
  =has_secure_password= method

* Sign up
User sign up worflow:
- user submits html form with singup information (cf 7.2)
- app creates a new user and saves its attributes to the database
  (cf. 7.4)
- the app renders a profile page w/ the newly created user information
We begin w/ a page /showing/ users (as a first step towards our REST
architecture for users). \\
We rely on the User model validations to increase the odds of new
users having valid emails. In ch11, we'll make sure of email validity
by adding a separate account activation step.

*Showing users*. \\
We make a page to display a user's name and profile photo (eventually
we're creating a profile page to show a user's profile image, basic
user data, and a list of microposts). 

Debug and Rails environments. \\
The profiles will be the first true piece of dynamic pages (i.e., the
view will be a singe page of code, but each profile will be customized
using information retrieved from the application's database). \\
We add debug information to our site layout by displaying useful
information using the =debug= method and =param= variable in
=app/views/layouts/application.html.erb=:
 : <%= debug(params) if Rails.env.development? %>

Rails environments. \\
Rails comes equipped w/ three environments: =test=, =development=, and
=production=. The default environment for the Rails console is
=development=. In the Rails console, =Rails.env= notifies us of the
current environment. To run a console in a different environment (to
debug a test, for instance), you can pass the environment as a
parameter: =$ rails console test=. You can also run different
environments: =$ rails server --environment production= to view your
app running in production. \\
To view the app running in production, we need a production database
(created by running =rails db:migrate= in production):
 : $ rails db:migrate RAILS_ENV=production

A users resource. \\
To make a user profile page, we need a user in the database: how can
the site have a user before there is a working signup page? We follow
the conventions of the REST architecture, which means representing
data as /resources/ that can be created, shown, updated, or
destroyed--four actions corresponding to the four fundamental
operations =POST=, =GET=, =PATCH=, and =DELETE= defined by the HTTP
standard. \\
When following the REST principles, resources are typically referenced
using the resource name and a unique identifier. In the context of
users--which we're now thinking of as a Users resource--we should view
the user with id 1 by issuing a =GET= request to the URL/users/1. Here
the =show= action is implicit in the type of request--when Rails' REST
features are activated, =GET= requests are automatically handled by
the =show= action. \\
Although we have the Users model already created, we get an
=ActionController::RoutingError= when the browser issues a =GET
/users/1= request. By adding =resources :users= to our
=config/routes.rb= file we now have all the REST routes for the user
resource (see =rails routes= command). \\
Now that we have the REST routing for the users resource (i.e.,
=POST=, =GET=, =PATCH=, and =DELETE= corresponding to the actions
create, show, update, and destroy), we still get an error when
requesting =GET /users/1= (returns an =Unknown action= error). \\
We begin with a minimalistic profile by displaying the name and email
inside the show template in the users views. Again, requesting results
in an =undefined method 'name' for nil:NilClass= error since we don't
have a =@user= instance variable inside the =show= controller. Inside
the =users_controller.rb=, we have:
: def show 
:   @user = User.find(params[:id])
: end
We use the =params= to retrieve the user id. When we make the
appropriate request to the Users controller, =params[:id]= will be the
user id specified in the URL (in this case =1=). The effect is
equivalent to =User.find(1)= (technically =params[:id]= is a string,
but Rails converts it to an integer before passing it to
=User.find=). 

Debugger. \\
Aside from using the =debug= method, we can use the =byebug= gem by
simply adding the line =debugger= to controllers we want to debug.
1) add =beybug= to =Gemfile=, then executed =$ bundle install=
2) add the text =debugger= in the controller actions to debug
3) when visiting that route & action, we can see the =(byebug)...= output
   inside the Gemfile
4) to release the prompt and continue execution of the application,
   press Ctrl-D, then remove the =dubugger= line from the action
Whenever confused about something in a Rails app, it's good practice
to put =debugger= close to the code you think might be causing the
trouble. Inspecting the state of =byebug= is a powerful method for
tracking down applications errors and interactively debugging your
application. 

A Gravatar image and a sidebar. \\
Rather than managing image uploads, cropping, and storage, we use
Gravatar (a free service that allows users to upload and associate
images with their email addresses). We delegate image handling to ch13
(which follows the enough to be dangerous motto). We define a
=gravatar_for= helper function to return a Gravatar image for a given
user. We want to put the following in the show users view:
: <%= gravatar_for @user %>
Recall: methods defined in any helper file are available in any view,
but we put the =gravatar_for= method in the file for helpers
associated with the Users controller (which makes sense
logically). Gravatar URLs are based on an MD5 hash of the user's email
address, so we need to convert our email using the =Digest= library:
: Digest::MD5::hexdigest(email.downcase)
The resulting helper =UsersHelper= function follows:
#+BEGIN_SRC ruby
# Returns the Gravatar for the given user.
def gravatar_for(user)
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"
  image_tag(gravatar_url, alt: user.name, class: "gravatar")
end
#+END_SRC
We add a user sidebar using the =aside= tag with bootstrap styling
(viz. =row= and =col-md-4= classes). With the html elements and css
classes in place, we can style the profile page w/ scss inside the
=app/assets/stylesheets/custom.scss=. 

*Singup form*. \\

Using =form_for=. \\
The =form_for= helper method takes in an active record  object and
builds a form using the object's attributes. Since =/signup= is routed
to the =new= action in the Users controller, we first create the User
object required as an argument to =form_for=:
#+BEGIN_SRC ruby
.../users_controller.rb
  def new
    @user = User.new
  end

.../new.html.erb
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(@user) do |f| %>
    <%= f.label :name %>
    <%= f.text_field :name %>
    <%= f.label :email %>
    <%= f.text_field :email %>
    <%= f.label :password %>
    <%= f.text_field :password %>
    <%= f.label :password_confirmation %>
    <%= f.text_field :password_confirmation %>
    <%= f.submit "Create my account", class: "btn btn-primary" %>
    <% end %>
  </div>
#+END_SRC

Signup form. \\
: <%= form_for(@user) do |f| %>
: ...
: <% end %>
The =form_for= take a block w/ one variable (viz. =|f|= for
"form"). When the =f= object is called w/ a method corresponding to an
html form element, =f= returns code for that element specifically
design to set an attribute of the =@user= object.
So =f.label= & =f.text_field= create the html needed to make a labeled
text field element appropriate for setting the =name= attribute of a
User model. The generated html attribute types =text= & =email= simply
display their contents, whereas type =password= obscures the input for
security reasons. Actually type =email= will cause mobile devices to
display a special keyboard optimized for entering email addresses. \\
As we see, the key to creating a yser us the special =name= attribute
in each =input=. They allow Rails to construct an initialization hash
(via the =params= variable) for creating users using the form
values. \\
Rails creates the =form= tag using the =@user= object: bc every Ruby
object knows its own class (Rails figures out that =@user= is of class
=User=). Moreover, since =@user= is a /new/ user (by the =new= method
call), Rails knows to construct a form w/ the =post= method. 
#+BEGIN_SRC ruby
<%= f.label :name %>
<%= f.text_field %>
# produces the HTML
<label for="user_name">Name</label>
<input id="user_name" name="user[name]" type="text" />

<%= f.label :email %>
<%= f.email_field :email %>
# produces the HTML 
<label for="user_email">Email</label>
<input id="user_email" name="user[email]" type="email" />

<%= f.label :password %>
<%= f.password_field :password %>
# produces the HTML
<label for="user_password">Password</label>
<input id="user_password" name="user[password]" type="password" />

<input name="utf8" type="hidden" value="&#x2713;" />
<input name="authenticity_token" type="hidden"
       value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" />
#+END_SRC
This code, which isn’t displayed in the browser, is used internally by
Rails, so it’s not important for us to understand what it
does. Briefly, it uses the Unicode character &#x2713; (a checkmark ✓)
to force browsers to submit data using the right character encoding,
and then it includes an authenticity token, which Rails uses to thwart
an attack called a cross-site request forgery (CSRF). Knowing when
it’s OK to ignore details like this is a good mark of technical
sophistication (Box 1.1).).

*Unsuccessful signups*. \\
We'll create a signup form that accepts an invalid submission and
re-renders the signup page with a list of errors.

A working form. \\
Our strategy for the =create= action is to use the form submission to
make a new user object using the =User.new= to save that user, and
then render the signup page for possible resubmission. Recall, from
the sign up we have:
: <form action="/user" class="new_user" id="new_user" method="post">
Our first implementation is to pass the generate =:user= (submitted by
the sign up form) to via the =params= method to =User.new= in the
=create= action. If unsuccessful, i.e. we cannot save the user, the
render the new action:
#+BEGIN_SRC ruby
def create
  @user = User.new(params[:user])  # not the final implementation
  if @user.save
    # Handle a successful save.
  else
    render 'new'
  end
end
#+END_SRC
When submitting the form with some invalid signup data, we get an
=ActiveModel::ForbiddenAttributesError=. The user hash gets passed to
the Users controller as part of =params=. In the case of posting to
the sign up form, =params= instead contains a hash of hashes.
#+BEGIN_SRC ruby
"user" => { "name" => "Foo Bar",
            "email" => "foo@invalid",
            "password" => "[FILTERED]",
            "password_confirmation" => "[FILTERED]"
          }

# the following two are essentially equivalent
@user = User.new(params[:user])
@user = User.new(name: "Foo Bar", email: "foo@invalid",
                 password: "foo", password_confirmation: "bar")
#+END_SRC

Strong parameters. \\
Recall: /mass assignment/ involves initializing a Ruby variable using
a hash of values. Initializing the entire =params= hash is dangerous--
it arranges to pass =User.new= all data submitted by the
user. Suppose, in addition to the current attributes, the User model
included an =admin= attibute to identify administrative users of the
site. To set such attribute =true= requires passing the value
: admin='1'
as part of =param[:user]=. Any client can do this via =curl=, hence
any client has access to administrative priveleges. \\
Previous versions of Rails used =attr_accessible= in the /model/ layer
to solve this problem, but the preferred technique is to use /strong
parameters/ (in the controller layer). Strong parmaters allow the
developer to specify which parameters are /required/ and which ones
are /permitted/. In addition, passing in a raw =params= hash as above
will cause an error to be raised, so that Rails applications are now
immune to mass assignment vulnerabilities by default. \\
We require the =params= hash to have a =:user= attribute, and we want
to permit the name, email, password, and password_confirmation
attributes (but not others), as follows:
=params.require(:user).permit(:name, :email, ...)=. The code returns a
version of the =params= hash with only the permitted attributes (while
raising an error if the =:user= attributes is missing). \\
Since user_params will only be used internally by the Users controller
and need not be exposed to external users via the web, we’ll make it
private using Ruby’s private keyword.
#+BEGIN_SRC ruby
def create
    @user = User.new(user_params)
    if @user.save
      # Handle a successful save.
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
#+END_SRC

Signup error messages. \\
As a final step in handling failed user creation, we'll add helpful
error messages to indicate the problem that prevented successful
signup. On a failed call of =user.save=, we can inspect what failed
validation via =user.errors.full_messages=. To display the messages in
the browser, we'll render an error-messages partial on the user =new=
page while adding the CSS class =form-control= to each entry. Note: we
=render= a partial called ='shared/error_messages'=; this reflects a
common Rails convention of using a dedicated =shared/= directory for
partials expected to be used in views accross multiple controllers.

A test for invalid submission. \\
We write tests to automate the testing of forms to verify the correct
behavior upon invalid form submission. First we generate an
integration test file for signing up users, which we'll call
=users_signup= (adopting the controller convention of plural resource
name):
: $ rails generate integration_test users_signup
We verify that clicking the signup button results in /not/ creating a
new user when the submitted information is invalid. We check the
/count/ of users, and under the hood our tests will use the =count=
method (available on every Active Record class, including =User=). \\
#+BEGIN_SRC ruby
$ rails console
>> User.count
=> 1
#+END_SRC


*Successful signups*
We handle saving anew user (if valid) to the database. 
- First, we try to save the user;
- if the save succeeds, the user's information gets written to the
  database automatically, and
- we then /redirect/ the browser to show the users profile (w/ a
  greeting)

The finished signup form. \\
To complete a working signup form (which freezes on submission), we
need to handle the successful branch of submit. The defualt behavior
for a Rails action is to render the corresponding view, and there
isn't a view template corresponding to =create=. 

The flash. \\
We add a message that appears on the subsequent page (welcoming our
new user to our application) and then disappears upon visiting a
second page or on page reload. \\
The Rails way to display a temporary message is via a method called
the /flash/, which we treat like a hash. Rails adopts the convention
of a =:success= key for a message indicating a successful result. 

A test for valid submission. \\

*Professional-grade deployment*. \\
Now that we have a working signup page, we will make the deployment
professional-grade. We add an important feature to the production app
to make signup secure, and replace the default webserver w/ one
suitable for real-world use. 

SSL in production. \\
We use Secure Sockets Layer to encrypt all relevant information before
it leaves the users local broser (via the submittion form). We use SSL
site-wide for two reasons: easier implementation and immune to the
critical seesion hijacking vulnerability (cf. 9.1). We enable SSL by
adding  =config.force_ssl = true= in
=config/environments/production.rb=. \\
Setting up a production site to use SSL requires purchasing and
configuring an SSL certificate for your domain. For applications
running on a Heroku domain, we can piggyback on Heroku's SSL
certificate (automatically enabled). 

Production webserver. \\
By default, Heroku uses a pure-Ruby webserver called WEBrick, which is
easy to set up and run but isn’t good at handling significant
traffic. As a result, WEBrick isn’t suitable for production use, so
we’ll replace WEBrick with Puma, an HTTP server that is capable of
handling a large number of incoming requests.

Conclusion. \\
We have laid an essential foundation for all future development. In
ch8 and ch9 we complete our authentication machinery by allowing users
to log in and out of the app (w/ optional 'remember me'
functionality). In ch10, we allow all users to update their account
information, and we allow site administrators to delete users, thereby
completing the full suite of Users resource REST actions from the
users section of =$ rails r=.

What we learned in this chapter:
- Rails displays useful debug information via the debug method.
- Sass mixins allow a group of CSS rules to be bundled and reused in
  multiple places.
- Rails comes with three standard environments: development, test, and production.
- We can interact with users as a resource through a standard set of REST URLs.
- Gravatars provide a convenient way of displaying images to represent users.
- The form_for helper is used to generate forms for interacting with
  Active Record objects.
- Signup failure renders the new user page and displays error messages
  automatically determined by Active Record.
- Rails provides the flash as a standard way to display temporary messages.
- Signup success creates a user in the database and redirects to the
  user show page, and displays a welcome message.
- We can use integration tests to verify form submission behavior and
  catch regressions.
- We can configure our production application to use SSL for secure
  communications and Puma for high performance.
* Basic login
We’ll implement a basic but still fully functional login system: the
application will maintain the logged-in state until the browser is
closed by the user. The authentication system will be customized based
on login status and identity of the current user. For example, we'll
be able to update the site header w/ login/logout links and a profile
link. \\
In ch10, we impose a security model in which:
- only logged-in users can visit the user index page,
- only the correct user can access the page for editing thier information,
- and only admin users can delete other users from the database.
In ch13, we use the identity of a logged-in user to create microposts
associated w/ the user. Ch14 allows the current user to follow other
users of the application (thereby receiving a feed of their
microposts). \\
The authentication system from this chapter will serve as a foundation
for the more advanced system of ch9 where, instead of 'forgetting'
users on browser close, we start by /automatically/ remembering users,
and will then optionally remember users based on the value of a
'remember me' checkbox.

*Sessions*. \\
HTTP is a stateless protocol. Treating each request as an independent
transaction that is unable to use information from any previous
request. The most common technique for implementing sessions in Rails
involves using cookies, which are small pieces of text placed on the
user's browser. We use the Rails method called =session= to make
temporary sessions that expire automatically on browser close. In ch9,
we'll learn how to make longer-lived sessions using the closely
related =cookies= method. \\
We model sessions as a RESTful resource:
- visiting the login page will render a form for /new/ sessions,
- logging in will /create/ a session,
- and logging out will /destroy/ it.
The session resource will use cookies (small piece of text placed on
the user's browser), and much of the work involved in login comes from
building this cookie-based authentication machinery. \\
We will prepare for constructing a Sessions controller, a login form,
and the relevant controller actions. We'll then complete user login by
adding the necessary session-manipulation code.

Sessions controller. \\
Logging in and out correspond to particular REST actions of the
Sessions controller:
- =GET new=: the login form is handled by the =new= action
- =POST create=: logging in is handled by sending a POST request to the =create= action
- =DELETE destroy= logging out is handled by sending a DELETE request to the =destroy=
  action
We begin by generating a Sessions controllers w/ a =new= action:
 : $ rails generate controller Sessions new
Following the model of the sign up page, our plan is to create a login
form for creating a new sessions. Unlike the Users resource, which
used the special =resource= method to get the full suite of RESTfull
routes, the Sessions resource will use only named routes, handling
the routes specified above:
: ./config/routes.rb
: get    '/login',    to: 'sessions#new'
: post   '/login',    to: 'sessions#create'
: delete '/logout',   to: 'sessions#destroy'
Since we've added several custom named routes, it's useful to look at
the complete list of route for our application via =$ rails
routes=. Viewing the routes in this manner gives us a high-level
overview of the actions supported by our applications.

Login form. \\
Having defined the relevant controller and route, now we'll fill in
the view for new sessions, i.e., the login form. The login form is
similar in appearance to the signup form, except with two fields
(email and password) in place of four. \\
When login information is invalid, we want to re-render the login page
and display an error message. We used error-messages partial to
display error messages, but we saw in that section that those messages
are provided automatically by Active Record. This won't work for
session creation errors bc the session isn't an Active Record object,
so we'll render the error as a flash message instead. \\
Recall, the signup form uses the =form_for= helper, taking as an
argument the user instance variable =@user= (see signup form). 
=form_for(@user)= allows Rails to infer that =action= of the form
should be to =POST= to the URL =/users=, in the case of sessions we
need to indicate the /name/ of the resource and the corresponding URL:
 : for_for(:session, url: login_path)
With the proper =form_for=, it's easy to make a login form to match
the mockup using the signup form as a model:
#+BEGIN_SRC ruby
<% form_for(:session, url: login_path) do |f| %>
  <%= f.label :email %>
  <%= f.email_field :email, class: 'form-control' %>

  <%= f.label :password %>
  <%= f.password_field :password, class: 'form-control' %>

  <%= f.submit "Log in", class: "btn btn-primary" %>
<% end %>
#+END_SRC

Finding and authenticating a user. \\
As in the case of creating users (signup), the first step in creating
sessions (login) is to handle /valid/ input. We 
- review what happens when a form gets submitted
- then arrange for helpful error messages to appear in the case of login failure
- then lay the foundations for successful login by evaluating each
  login submission based on the validity of its email/password
  combination
We start w/ a minimalist =create= action for the Sessions controller
and add an empty action =new= and =destroy=. \\
Inspecting the debug information, the submission results in a =params=
hash containing the email and password under the key =session= (see
below). As weas in the case of the user signup, these parameters form
a nested hash like the one for the user signup. In particular,
=params= contains a nested hash of the form: ={ session: { password:
"...", email: "..." } }=. This means that =params[:session]= is itself
a hash. Hence, inside the =create= action the =params= hash has all
the information needed to authenticate users by email and
password.
#+BEGIN_SRC ruby
--- !rub/object:ActionController::Parameters
session: !ruby/object:ActionController::Parameters
  parameters: !ruby/hash:ActiveSupport::HashWithIndifferentAccess
    email: ...
    password: ...
...
#+END_SRC
 Not coincidentally, we already have a method for
=User.find_by= method provided by =has_secure_password=. Recall,
=authenticate= returns false for an invalid authentication. Our
strategy for user login can be summarized as 
: if user exists AND user is authenticated
:  user = find user by (lowercase) email
:  Log the user in and redirect to the user's show page
: else
:  Create an error message
:  render 'new'
The =&&= (logical /and/) is used to determine if the resulting user is
valid. Taking into account that any object other than =nil= and
=false= itself is =true= in a boolean context, the possibilities are:
| User        | Password       | a && b                       |
| nonexistent | anything       | (nil && [anything]) == false |
| valid user  | wrong password | (true && false) == false     |
| valid user  | right password | (true && true) == true       |

Rendering with a flash message. \\
Recall- we displayed the signup errors using the User model error
messages:
#+BEGIN_SRC ruby
./app/views/shared/_error_message.html.erb
<% if @user.errors.any? %>
<div id="error_explanation">
  <div class="alert alert-danger">
    The form contains <%= pluralize(@user.errors.count, "error") %>
  </div>
  <ul>
    <% @user.errors.full_messages.each do |msg| %>
    <li><%= msg %></li>
    <% end %>
  </ul>
</div>
<% end %>

./app/views/users/new.html.erb
  <%= form_for(@user, url: signup_path) do |f| %>
    <%= render 'shared/error_messages' %>
    ...
  <% end %>
#+END_SRC
The errors are associated w/ a particular Active Record object, but
this strategy won't work here bc the session isn't an active record
model. Instead, we'll put a message in the flash to be displayed upon
failed login as:
: flash[:danger] = 'Invalid email/password combination'
Bc of the flash message display in the site layout, the
=flash[:danger]= message automatically gets displayed and styled by
the Bootstrap CSS:
#+BEIGN_SRC ruby
./app/views/layouts/application.html.erb
<div class="container">
  <% flash.each do |message_type, message| %>
  <div class="alert alert-<%= message_type %>">
    <%= message %>
  </div>
<% end %>
#+END_SRC
Unfortunately, this code isn't quite right. The page looks fine, but
the issue is that the contents of the flash persist for one /request/,
but--unlike a redirect-- re-rendering a template with =render= doesn't
count as a request. The result is the flash message persists one
request longer than we want. \\
Ex- submitting an invalid login information and then clicking on the
Home page results in the flash message displayed a second time. We
will fix this belimish next.

A flash test. \\
The incorrect flash behavior is a minor bug in our application. This
situation (according to our testing guidelines Box 3.3) is exactly the
sort of situation where we should write a test to catch the error so
it doesn't recur. \\
We write a short integration test for the login form submission before
proceeding. The benefits of this integration test are:
- documenting the bug,
- preventing a regression,
- and this weill also give us a good foundation for further
  integration tests of login and layout. 
We start by generating an integration test for our application's login
behavior =$ rails generate integration_test users_login=. Next, we
need a test to capture the sequence of behavior where the bug occurs:
1) visit the login path
2) verify the new sessions form renders properly
3) post to the session path with an invalid =params= hash
4) verify that the new sessions form gets re-rendered and that a flash
   message appears
5) visit another page (such as the Home page)
6) verify that the flash message /doesn't/ appear on the new page
#+BEGIN_SRC ruby
./test/integration/users_login_test.rb
class UsersLoginTest < ActionDispatch::IntegrationTest
  test "login with invalid information"
    get login_path
    assert_template 'sessions/new'
    post login_path, params: { session: { email: "", password: "" } )
    assert_template 'sessions/new'
#+END_SRC

*Logging in*. \\
Now that our login can handle invalid submissions, the next step is to
handle valid submissions correctly by actually loggin a user in. We
log the user in w/ a temporary session cookie that expires
automatically upon the browser close. We add sessions that persist
even after closing the browser. \\
Implementing sessions involves defining a large number of related
functions for use accross multiple controllers and views. Recall- Ruby
provides a /module/ facility for packaging such functions in one
place. Conveniently, a Sessions helper module was generated
automatically when generating the Sessions controller. Such helpers
are automatically included in Rails views; by including the module
into the base class of all controllers (the Application controller),
we arrange to make them available in our controllers as well. 
: class ApplicationController < ActionController::Base
:   protect_from_forgery with: :exception
:   Include SessionsHelper
: end 

The =log_in= method. \\
Logging a user in is simple w/ the help of the =session= method
defined by Rails (seperate and distinct from the Sessions
controller). We can treat =session= as if it were a hash, and assign
to it: =session[:user_id] = user.id=. This places a temporary cookies
on the user's browser containing an encrypted version of the user's
id, which allows us to retrieve the id on subsequent pages using 
=session[:user_id]=. The temporary cookie created by the =session=
method expires immediately when te browser is closed. \\
Bc we want to use the same login technique in a couple different
places, we'll define a method called =log_in= in the Sessions helper
(see below). Bc temp cookies created using the =session= method are
automatically encrypted, the code below is secure (applies only to
temp sessions via =session= method, not w/ sessions via =cookie=
method). Permanent cookies are vulnerable to session hijacking attacks
(cf. ch9). \\

#+BEGIN_SRC ruby
./app/helpers/sessions_helper.rb
module SessionsHelper
  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
end

./app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
  ...
  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end
  ...
end
#+END_SRC


Current user. \\
Now that we placed the user's id securely in the temporary session, we
are now in a position to retrieve it on subsequent pages, which we'll
do by defining a =current_user= method to find the user in the
database corresponding to the session id. The purpose of the
=current_user= is to allow constructions such as
: <%= current_user.name %>
and
: redirect_to current_user
To find the current user, one possibility is to use the =find= method,
as on the user profile page =User.find(session[:user_id])=. Recall-
=find= raises an exception if the user id doesn't exist. This behavior
is appropriate on the user profile page bc it will only happen if the
id is invalid, but in the present case =session[:user_id]= will often
be =nil= (i.e. for non-logged-in users). To handle this possiblity,
we'll use the same =find_by= method used to find by email address in
the =create= method, with =id= in place of =email=:
: User.find_by(id: session[:user_id])
Rather than raising an exception, this method returns =nil=
(indicating no such user) if the id is invalid. This works fine, but
it hits the database multiple times if, e.g. =current_user= appeared
multiple times on a page. Instead, we'll follow a common Ruby
convention by storing the result of =User.find_by= in an instance
variable, which hits the db the first time but returns the instance
variable immediately on subsequent invocations: 
#+BEGIN_SRC ruby
if @current_user.nil?
  @current_user = User.find_by(id: session[:user_id])
else
  @current_user
end

... more sufficiently rewritten as
@current_user = @current_user || User.find_by(id: seesion[:user_id])

... idiomatically as
@current_user ||= User.find_by(id: session[:user_id])
#+END_SRC

Changing the layout links. \\
The first practical application for logging in involves changing the
layout links based on the login status. In particular, we add links
for logging out, links for user settings, for listing all users, and
for the current user's profile page. \\
At this point, I would consider writing an integration test to capture
the behavior described above. As you become mroe familiar w/ the
testing tools in Rails you may find yourself more inclined to write
tests first. In this case, such a test involves several new ideas, so
for now it's best to defer for later. \\
The way to change links in the site layout involves using an if-else
statement inside embedded Ruby to show one set of links if the user is
logged in and another, otherwise (see below). We use a =logged_in?=
boolean method, which determines if a user has logged in. \\
Recall- a user is logged in if there is a current user in the session,
i.e., if =current_user= is not =nil=. Checking for his requires the
use of the 'not' operator written using an exclamation point =!= (read
'bang'). The resulting =logged_in?= method appears below. \\
We're now ready to change the layout links if a user is logged
in. There are four new links (two stubbed out). Below is a concise
version of the conditional header template. \\
We need to include Bootstrap's ability to make dropdown menus (see
below). Not in particular the inclusion of the special Bootstrap CSS
classes such as =dropdown=, =dropdown-menu=, etc. To activate the
dropdown menu, we need to include Bootstrap's custom JavaScript
library in the Rails asset pipeline's =application.js= file. \\
#+BEGIN_SRC ruby
# conditional templating
  <% if logged_in? %>
    # Links for logged-in users
  <% else %>
    # Links for non-logged-in-users
  <% end %>

./app/helpers/sessions_helper
module SessionsHelper
  ...
  # Return true if the user is logged in, false otherwise.
  def logged_in?
    !current_user.nil?
  end
  ...
end

./app/views/layouts/_header.html.erb
<header class="navbar navbar-fixed-top navbar-inverse">
<div class="container">
  <nav>
    <ul class="nav navbar-nav navbar-right">
      <li><%= link_to "Home", root_path %></li>
      <li><%= link_to "Help", help_path %></li>
      <% if logged_in? %>
        <li><%= link_to "User", '#' %></li>
        <li class="dropdown-menu">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">
            Accoutn
          </a>
          <ul class="dropdown-menu">
            <li><%= link_to "Profile", current_user %></li>
            <li><%= link_to "Settings", '#' %></li>
            <li><%= link_to "Log out", logout_path, method: delete %></li>
          </ul>
        </li>
      <% else %>
        <li><%= link_to "Log in", login_path %></li>
      <% end %>
    </ul>
  </nav>
</div>
</header>

./app/assets/javascript/application.js
//= require jquery
...
//= require bootstrap
...
#+END_SRC

Testing layout changes. \\
Having verified by hand that the app is behaving properly upon
successful login, before moving on we'll write an integration test to
capture that behavior and catch regressions. \\
We build on the test the login integration test and write a series of
steps to verify the following sequence of actions:
1) visit the login path
2) post valid information to the sessions path
3) verify that the login link disappears
4) verify that a logout link appears
5) verify that a profile link appears
In order to see these changes, our test needs to log in as a previously
registered user, which means that such a user must already exist in
the database. The default Rails way to do this is to use /fixtures/,
which are a way of organizing data to be loaded into the test
database (which we deleted so our email uniqueness tests would
pass). Now we're ready to start filling in the empty file w/ custom
fixtures of our own. \\
In the present case, we need only one user, whose information should
consist of a valid name and email address. Bc we'll need to log the
user in, we also have to include a valid password to compare w/ the
password submitted to the Sessions controller's =create=
action. Referring to the data model, we see that this means creating a
=password_digest= attribute for the user fixture, which we accomplish
by defining a =digest= method of our own. \\
Te password digest is created using bcrypt (via
=has_secure_password=), so we'll need to create the fixture password
using hte same method. By inspecting the secure password source code,
we find the metod is =BCrypt::Password.create(string, cost: cost)=
where =string= is the string to be hashed and =cost= is the /cost/
parameter that determines the computational cost to calculate the
hash. Using a high cost makes it computationally intractable to use
the hash to determine the original password, which is an important
security precaution in a production environment, but in tests we want
the =digest= metod to be as fast as possible. The secure password
source code has a line for this as well:
: cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost
There are several places we could put the resulting =digest= method,
but we'll have an opportunity to reuse =digest= in the User mode. This
suggest placing the method in =user.rb=. Bc we won't necessarily have
access to a user object when calculating the digest (as will be the
case in the fixutres file), we'll attach the digest method to the User
class itself, which makes it a class method. \\
Below, we define the =Foo= user fixture. Note, fixtures support
embedded Ruby, which allows us to use the User class method
=User.digest= to create a valid password digest for the test
user. Although, we've defined the =password_digest= attributes
required by =has_secure_password=, sometimes it's convenient to refer
to the plain (virtual) password as well. This is impossible to arrange
w/ fixtures, and adding a =password= attribute cuases Rails to
complain that there is no such column in the db (true). We'll make do
by adopting the convention that ll fixture users have the same
password =password=. \\
Having created a fixture w/ a valid user, we can retrieve it inside a
test as follows:
: user = users(:foo)
Here =users= corresponds to the fixture filename =user.yml=, while the
symbol =:foo= references user w/ the key shown. With the fixture user
as above, we can now write a test for the layout links by converting
the sequence enumerated at the beginning of this section into code
(see below). \\
We've used the =assert_redirected_to @user= to check the right
redirect target and followed the target by use of
=follow_redirect!=. We also verified the login link dsappears by
verifying there are /zero/ login paths on the redirected page. 
#+BEGIN_SRC ruby
./app/models/user.rb
class User < ApplicationRecord
  ...
  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end
end

./test/fixtures/user.yml
foo:
  name: Foo Example
  email: foo@bar.baz
  password_digest: <%= User.digest('password') %>

./test/integration/users_login_test.rb
require 'test_helper'
class UsersLoginTest < ActionDispatch::IntegrationTest
  def setup
    @user = users(:foo)
  end
  ...
  test "login with valid information" do
    get login_path
    post login_path, params: { session: { email: @user.email,
                                          password: 'password' } }
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'
    assert_select "a[href=?", login_path, count: 0
    ...
  end
end
#+END_SRC

Login upon signup. \\
Newly registered users are not logged in by default. We log in new
users automatically as part of the signup process. To arrange this
behavior, all we need to do is add a call to =log_in= in the Users
controller =create= action (see below). \\
To arrange this behavior, all we need to do is add a call to the
=log_in= in the Users controller =create= action (right after we save
the newly created user). \\
To test the behavior, we can add a line to the test to check that the
user is logged in. It's helpful in this context to define an
=is_logged_in?= helper method to parallel the =logged_in?= helper
defined which returns =true= if there's a user id in the (test)
seesion and false otherwise. With the helper method, we can assert
that the user is logged in after signup by appending =assert
is_logged_in?= at the end of the =valid signup information= test. 

*Logging out*. \\
Our authentication model is to keep users logged in until they log out
explicitly. We add the necessary logout capability. Bc the "Log out"
link has already been defined, all we need is to write a valid
controller action to destroy user sessions. \\
So far, the Sessions controller actions have followed the RESTful
convention of using =new= for a login page and =create= to complete
the login. We'll continue this theme by using a =destroy= action to
delete sessions, i.e., to log out. Unlike the login functionality,
we'll only be logging out in one place, so we'll put the relevant code
directly in the =destroy= action. Wth a little refactoring, we will
also make the authentication machinery easier to test. \\
Logging out involves undoing the effects of the =log_in= method from
which involves deleting the user id from the ession. To do this, we
wuse the =delete= method as follows: =session.delete(:user_id)=. We
also set the current user to =nil=, although in the present case this
won't matter bc of an immediate redirect to the root URL. As with 
=log-in= and associated methods, we'll put the resulting =log_out=
method in the Sessions helper module (see below). \\
To test the logout machinery, we can add some steps to the user login
test. After logging in, we use =delete= to issue a =DELETE= request to
the logout path and verify the user is logged out and redirected to
the root URL. 
#+BEGIN_SRC ruby
./app/helpers/session_helper.rb
module SessionsHelper
  # Logs in the given user.
  def login(user)
    session[:user_id] = user.id
  end
  ...
  # Logs out the current user.
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end

./test/integration/users_login_test.rb
require 'test_helper'
class UsersLoginTest < ActionDispatch::IntegrationTest
  ...
  test "login with valid information followed by logout" do
    get login_path
    ...
    assert is_logged_in?
    ...
    delete logout_path
    assert_not is_logged_in?
    assert_redirect_to root_url
    follow_redirect!
    assert_select "a[href=?]", login_path
    assert_select "a[href=?]", logout_path,      count: 0
    assert_select "a[href=?]", user_path(@user), count: 0
  end
end
#+END_SRC
* TODO why do we have two alia for user#new
One alias is GET user#new for signup, I guess after signing up you get
that user returned back
The other is 

Login form. \\
Having defined the relevant controller and route, now we'll fill in
the view for new sessions, i.e., the login form. The login view is
similar to the signup form, except with two less fields. When the
login information is invlaid, we want to re-render the login page with
a flash message displaying the error message. We have already defined
an error-messages partial to display error-messages, but those
messages are provided automatically by Active Record. This won't work
for sessions creation errors bc the session isn't an Active Record
object, so we'll render the error as a flash mesage instead. \\
Recall, the signup form uses the =form_for= helper, taking a =@user=
argument. The main difference between the session form and signup form
is that we have no Session model (hence no analogue for the =@user=
variable). In constructing a new session form, we have to give
=form_for= slightly more information (as opposed to =form_for(@user)=
which allows Rails to infer that the =action= of the form should be
to POST to the URL =/users=). We need to indicate the name of the
resource corresponding to the URL: =form_for(:session,
url:login_path)=. 

Finding and authenticating a user. \\
First we handle invalid input in the case of creating sessions,
i.e. /login/ (just as we did for creating users in /login/).
- we review what happens when a form gets submitted
- we arrange for helpful error messages to appear in the case of login
  failure
- we lay the foundation for successful login by evaluating each login
  based on validity of email/password combination
Lets begin by defining the =create= action of the Sessions controller
(along w/ =new= and =destroy= actions). The =create= action does
nothing but render the =new= view equivalent to =/sessions/new=. So we
place
: render 'new'
in the =create= action of SessionsController.rb. Inspecting the debug
infromation after a submission results in a =params= hash containing
the email and password under the key =session=. \\
Inside the =create= action the =params= hash has all the information
needed to authenticate users by email and password:
- =User.find_by= method provided by Active Record, and
- =authenticate= method provided by =has_secure_password=.
Our strategy for user login can be summarized (as shown below):
1) pull the user out of the database using submitted email (downcased)
2) if the resulting user is not =nil= or =false= and is valid, then
   execute the Log in code
#+BEGIN_SRC ruby
# debug dump
---
session:
  email: 'user@example.com'
  password: 'foobar'
commit: Log in
action: create
controller: sessions

params: { session: { password: "foobar", email: "user@example.com" } }
params[:session][:email] == "user@example.com"
params[:session][:password] == "foobar"

app/controllers/sessions_controller.rb
...
def create
  user = User.find_by(email: params[:session][:email].downcase)
  if user && user.authenticate(params[:session][:password])
    # Log the user in and redirect to the user's show page.
  else
    # Create an error message.
    render 'new'
  end
end
...
#+END_SRC

Rendering with a flash message. \\
Recall that we displayed signup errors using the User model error
messages. These errors are associated w/ a particular Active Record
object, but this strategy won't work here bc the session isn't an
Active Record model. Instead, we'll put a message in the flash to be
displayed upon failed login. \\
Bc of the flash message display in the site layout, the
=flash[:danger]= message automatically gets displayed. The page looks
fine, but the contents of the flash persist for one request longer. \\


#+BEGIN_SRC ruby


app/controllers/sessions_controller.rb
...
def create
  user = User.find_by(email: params[:session][:email].downcase)
  if user && user.authenticate(params[:session][:password])
    # Log the user in and redirect to the user's show page.
  else
    # Create an error message.
    flash[:danger] = "invalid email/password combination' # not right
    render 'new'
  end
end
...
#+END_SRC

A flash test. \\
The incorrect flash behavior has a minor bug in our app. We'll thus
write a test to catch the error so that it doesn't recur. We'll thus
write a short integration test for the login form submission before
proceeding. In addition to documenting the bug and preventing a
regression, this will also give us a good founddation for further
integration tests of login and logout. \\
The way to get the failing test to pass is to replace =flash= w/
=flash.now= (designed for displaying flash messages on rendered
pages). The contents of =flash.now= disappear as soon as there is
an addtional request (exactly the behavior our
=test/integration/users_login_test.rb= expect).

*Logging in*. \\
Now that our login can handle invalid submissions, the next step is to
handle valid submissions correctly by actually logging a user in. We'll
log the user in w/ a temporary sessions cookie that expires
automatically upon browser close. We'll add sessions that persist even
after closing the browser. \\
Implementing sessions involves defining a large number of related
functions for use accross multiple controllers and views. Ruby
provides a /module/ facility for packaging such functions in one
place. Conveniently, a Sessions helper module was generated
automatically when generating the Sessions controller. Moreover, such
helpers are automatically included in Rails views; by including the
module into the base class of all controllers (the Applicatioin
controller), we arrange to make them available in our controllers as
well. 
#+BEGIN_SRC ruby
./app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper
end
#+END_SRC

The =log_in= method. \\
We can treat =session= as if it were a hash, and assign to it as
follows:
: session[:user_id] = user.id
This places a temporary cookie on the user's browser containing an
encrypted version of the user's id, which allows us to retrieve the id
on subsequent pages using =session[:user_id]=. In contrast to the
persistent cookie created by the =cookies= method, the temporary
cookie created by the =session= method expires immediately when the
browser is closed. We define =log_in= in the Sessions helper. \\
Bc temporary cookies created using the =session= method are
automatically encrypted, the code is secure, and there is no way for
an attacker to use the sessions initiated w/ the =session= method (not
the case for persistent sessions created using the =cookies=
method). Permanent cookies are vulnerable to a session /hijacking/
attack. So ch9, we'll have to be much more careful about the
information we place on the user's browser. \\
With the =log_in= method defined, we're now ready to complete the
session =create= action by logging the user in and redirecting to the
users profile. Note: =redirect_to user= converts this to the route
=user_url(user)=. \\
The login form should be working, although there is no way to tell
that you're logged in. As a first step toward enabling more visible
changes, we'll retrieve the current user from the database using the
id in the session. We'll change the links on the application layout,
including a URL to the current user's profile.
#+BEGIN_SRC ruby
./app/helpers/session_helper.rb
module SessionsHelper
  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
end

./app/controller/sessions_controller.rb
...
  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'now'
    end
  end
#+END_SRC

Current user. \\
Having placed the user's id securely in the temporary session, we are
now in a position to retrieve it on subsequent pages, which we'll do
by defining a =current-user= method to find the user in the database
corresponding to the session id. The purpose of =current_user= is to
allow constructions such as 
: <%= current_user.name %>
: redirect_to current_user
Recall: =find= raises an exception if the user id doesn't exist. This
behavior is appropriate on the user profile page because it will only
happen if the id is invalid, but in the present case
=session[:user_id]= will often be =nil=. 

 
