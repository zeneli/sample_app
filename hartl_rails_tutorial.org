#+STARTUP: indent
* beginning
*Version control with Git*. \\
Undoing things a la Git. \\
- git status : everything is fine
- rm -rf app/controllers
- git status : D'oh!
- git checkout -f : undo the changes of the working tree by force
  overwriting the current changes.

* Mostly Static Pages
The application will eventually have users, microposts, and a full
login and authentication framework. \\
We begin with static pages, a highly instructive exercise, rich in
implications. We will get a first taste of automated testing, which
will help us be more confident that our code is correct. Moreover,
having a good test suite will allow us to /refactor/ our code with
confidence, changing its form without changing its function. 

*Sample app setup Git*. \\
The commit and push sequence below is the kind of pattern that should
be followed in real-life development.
1) git checkout -b static-pages
2) rails generate controller StaticPages home help
3) git add -A
4) git commit -m "Add a Static Pages controller"
5) git push -u origin static-pages
6) git push

*Undoing things a la Rails*. \\
Controllers
1) rails generate controller StaticPages home help
2) rails destroy controller StaticPages home help
Models
1) rails generate model User name:string email:string
2) rails destroy model User
Migrations
1) rails db:migrate
2) rails db:rollback    undo a single migration
3) rails db:migrate VERSION=0    undo to the beginning

=GET=. \\
HTTP defines the basic operations =GET=, =POST=, =PATCH=, and
=DELETE=. These refer to operations between a /client/ computer and a
/server/. An emphasis on HTTP verbs is typical of web frameworks
influenced by the /REST architecture/.
- =GET=: used for /reading/ data on the web
- =POST=: the request sent by your browser when you submit a form
- =PATCH=: updating
- =DELETE=: destroying
The last two are less common commong then =GET= and =POST= since
browsers are incapable of sending them natively, but web frameworks
(including Rails ) have clever ways of making it /seem/ like 
browsers are issuing such request.

*Killing Spring server*. \\
Spring processes sometimes accumulate and slow performance of your
tests. If tests appear sluggish, its a good idea to inspect system
process and kill them if necessary. \\
- =ps aux=: display all process on system
- =ps aux | grep spring=: display spring processes
- =kill -15 pid=: issue Unix termination signal =-15= to kill process =pid=
- =spring stop=: try stopping spring through its command
- =pkill -15 -f spring=: if =spring stop= fails, then kill all
  processes with name =spring=

*Guard*. \\
The =rails test= command requires us to switch to the command line and
run the tests by hand. We can automate this behavior with Guard. Guard
monitors the filesystem so that, for example, when we change the
=static_pages_controller_test.rb= file, only those tess get run. Even
better, we can configure Guard so that when, say, the =home.html.erb=
file is modified, the =static_pages_controller_test.rb= automatically
runs. \\
1) =bundle exec guard init= (one time setup step)
2) =bundle exec guard= automatically run tests
   1) return to run all the tests
   2) Ctrl-D to exit
* Rails-flavored Ruby
*Motivation*. \\
Ruby is a big language, but the subset needed to be productive as a
Rails developer is relatively small. This chapter is designed to give
you a solid foundation in Rails-flavored Ruby. \\

Built-in helpers. \\
From =app/views/layouts/application.html.erb= we have a line
#+BEGIN_SRC ruby
<%= stylesheet_link_tag 'application', media: 'all',
                                       'data-turbolinks-track': 'reload' %>
#+END_SRC
This uses the built-in Rails function =stylesheet_link_tag= to include
=application.css= for all media types. There are four Ruby ideas:
- built-in Rails methods
- method invocation with missing parentheses
- symbols
- hashs

Custom helpers. \\
Rails allows the cration of built-in functions called /helpers/. Its
good convention to have a /base tite/ we use on every page, with an
optional page title if we want to be more specific. In the static
pages section, if we removed the =provide(:title, "...")= we would not
yield anything to the title tag. This problem can be solved with a
helper function =full_title=.
#+BEGIN_SRC ruby
module ApplicationHelper
  # Return the full title on a per-page basis.
  def full_title(page_title='')
    base_title = "Ruby on Rails Tutorial Sample App"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end 

<title><%= full_title(yield(:title)) %></title>
#+END_SRC
The helper code above is full of Ruby ideas: modules, method
definition, optional method argument, comments, local variable
assignment, booleans, control flow, string concatenation, and return
values.

*Strings and methods*. \\
Our principal tool for learning Ruby will be the /Rails console/
(built on irb). The console is a great learning tool. 
- Ctrl-C is you get stuck
- Ctrl-D to exit the console

Strings are the most important data structure for web apps, since web
pages ultimately consist of strings of characters sent from the server
to the browser.
- string literal: "foo"
- string concat: "foo" + "bar"
- string assign: first_name = "Lupo"
- string interp: "#{first_name} Zeneli", but not '#{first_name} Zeneli'
To /print/ a string to the screen, the most commonly used Ruby
function is =puts=. The =puts= method operates as a /side-effect/: a
=puts= expression prints the argument to the screen then returns
=nil=. 
=print= prints the raw string without a newline char like =puts=. \\

Object and message passing. \\
Everything in Ruby is a an object; you have to build your intuition
for objects by seeing lots of examples. Its easier to describe what
objects do, i.e respond to messages. Messages that get passed to
objects are /methods/, which are functions defined on those
objects. \\
Ex: Strings respond to the =empty?= method. \\
=!!= coerces an object to its boolean value.

Note that Ruby functions have an /implicit return/, meaning they
return the last statement evaluated. So the following two definitions
of =string_message= are equivalent.
#+BEGIN_SRC ruby
def string_message(str='')
  if str.empty?
    "Its an empty string!"
  else
    "The string is nonempty."
  end
end

def string_message(str='')
  return "Its an empty string!" if str.empty?
  return "The string is nonempty."
#+END_SRC
The second return of the second =string_message= function is
unnecessary--being the last expression means it will be returned
regardless of the keyword =return=. In this case, we make the return
explicit for readability. \\
#+BEGIN_SRC
def palindrome_tester(s)
  if s == s.reverse
    puts "It's a palindrome!"
  else
    puts "It's not a palindrome."
  end
end
#+END_SRC

Back to title helper. \\
#+BEGIN_SRC ruby
module ApplicationHelper
  # Returns the full title on a per-page basis.       # Documentation comment
  def full_title(page_title = '')                     # Method def, optional arg
    base_title = "Ruby on Rails Tutorial Sample App"  # Variable assignment
    if page_title.empty?                              # Boolean test
      base_title                                      # Implicit return
    else
      page_title + " | " + base_title                 # String concatenation
    end
  end
end
#+END_SRC
Modules provide a way to package together related methods, which can
then be /mixed in/ to Ruby classes using =include=. When writing
ordinary Ruby, you often write modules and include them explicitly
yourself. In the case of a helper module Rails handles the inclusion
for us. The result is that the =full_title= method is available in all
our views. 

*Other data structures*. \\
Web apps are ultimately about strings, but /making/ those strings
requires other data structures as well. 

Arrays and ranges. \\
Understanding arrays provides a foundation for understanding hashes
and aspects of Rails data modeling (e.g =has_many= associations). Ruby
arrays are zero-offset. In additon to the conventional square bracket
syntax for accessing array elements, Ruby offers synonyms =first=,
=second=, and =last=. 
#+BEGIN_SRC ruby
>> # split on defualt; space 
>>  "foo bar     baz".split     # Split a string into a three-element array.
=> ["foo", "bar", "baz"]
>> # split on 'x'
>> "fooxbarxbazx".split('x')
=> ["foo", "bar", "baz"]

>> # none of the methods change the array a
>> a
=> [42, 8, 17]
>> a.empty?
=> false
>> a.include?(42)
=> true
>> a.sort
=> [8, 17, 42]
>> a.reverse
=> [17, 8, 42]
>> a.shuffle
=> [17, 42, 8]
>> a
=> [42, 8, 17]

>> # mutator methods of arrays ("bang" suffix)
>> a
=> [42, 8, 17]
>> a.sort!
=> [8, 17, 42]
>> a
=> [8, 17, 42]

>> # push operations; arrays contain mixture of types
>> a.push(6)                  # Pushing 6 onto an array
=> [42, 8, 17, 6]
>> a << 7                     # Pushing 7 onto an array
=> [42, 8, 17, 6, 7]
>> a << "foo" << "bar"        # Chaining array pushes
=> [42, 8, 17, 6, 7, "foo", "bar"]

>> # join: inverse of split
>> a
=> [42, 8, 17, 6, 7, "foo", "bar"]
>> a.join                       # Join on nothing.
=> "4281767foobar"
>> a.join(', ')                 # Join on comma-space.
=> "42, 8, 17, 6, 7, foo, bar"

>> # ranges to arrays via to_a
>> 0..9
=> 0..9
>> 0..9.to_a              # Oops, call to_a on 9.
NoMethodError: undefined method `to_a' for 9:Fixnum
>> (0..9).to_a            # Use parentheses to call to_a on the range.
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> # slicing: pulling out array elements
>> a = %w[foo bar baz quux]         # Use %w to make a string array.
=> ["foo", "bar", "baz", "quux"]
>> a[0..2]
=> ["foo", "bar", "baz"]
>> # slice to the end; -1 trick
>> a = (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..(a.length-1)]               # Explicitly use the array's length.
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..-1]                         # Use the index -1 trick.
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> # character ranges
>> ('a'..'e').to_a
=> ["a", "b", "c", "d", "e"]
#+END_SRC

Blocks. \\
Arrays and ranges respond to a host of methods that accept /blocks/.
=(1..5).each { |i| puts 2 * i }= calls the =each= method on the range
=(1..5)= and passes the block as an argument to =each=.  =|i|= is Ruby
syntax for a block varaible. In the Rails Tutorial we’ll follow the
common convention of using curly braces only for short one-line blocks
and the do..end syntax for longer one-liners and for multi-line
blocks. \\
To understand blocks, you have to see them a lot and eventually get
used to them. Below are a few examples that use the =map= method on
arrays and ranges. The =map= method returns the result of applying the
given block to each element of the array or range. 
#+BEGIN_SRC ruby
>> (1..5).each do |i|
?>   puts 2 * i
>> end
246810=> 1..5
>> (1..5).each do |number|
?>   print 2 * number
>>   print '--'
>> end
2--4--6--8--10--=> 1..5

>> 3.times { puts "Betelgeuse!" }   # 3.times takes a block with no variables.
"Betelgeuse!"
"Betelgeuse!"
"Betelgeuse!"
=> 3
>> (1..5).map { |i| i**2 }          # The ** notation is for 'power'.
=> [1, 4, 9, 16, 25]
>> %w[a b c]                        # Recall that %w makes string arrays.
=> ["a", "b", "c"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"]
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]

>> # when calling a method of the variable use "symbol-to-proc"
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]
>> %w[A B C].map(&:downcase)
=> ["a", "b", "c"]

>> # generate random subdomains
>> ('a'..'z').to_a                     # An alphabet array
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
>> ('a'..'z').to_a.shuffle             # Shuffle it.
=> ["c", "g", "l", "k", "h", "z", "s", "i", "n", "d", "y", "u", "t", "j", "q",
"b", "r", "o", "f", "e", "w", "v", "m", "a", "x", "p"]
>> ('a'..'z').to_a.shuffle[0..7]       # Pull out the first eight elements.
=> ["f", "w", "i", "a", "h", "p", "c", "x"]
>> ('a'..'z').to_a.shuffle[0..7].join  # Join them together to make one string.
=> "mznpybuj"
#+END_SRC

Hashes and symbols. \\
Hashes are indicated with curly braces containing key-value
pairs. Hashes doe not guarantee keeping elements in a particular
order. If order matters, use an array. hash value for an undefined key
is simply nil. \\
Although hashes can accept any object as a key, its more common to use
symbols. Symbols represent a single entity (rather then a set of
characters such as strings) so they are compared easily in O(1)
time. This makes them ideal as key representations. The
symbol/hashrocket construction follows the hash notation of other
languages (such as JS). =:name =>= and =name:= are effectively the
same /only inside literal hashes/. \\
Hash values can be virtually anything, even other hashes (cf. code
below). These nested hashes are heavily used by Rails. Hashes (like
ranges and arrays) respond to the =each= method (cf. code below). \\
Note. =inspect= returns a string with a literal representation of the
object it's called on.

#+BEGIN_SRC ruby
>> user = {}                          # {} is an empty hash.
=> {}
>> user["first_name"] = "Michael"     # Key "first_name", value "Michael"
=> "Michael"
>> user["last_name"] = "Hartl"        # Key "last_name", value "Hartl"
=> "Hartl"
>> user["first_name"]                 # Element access is like arrays.
=> "Michael"
>> user                               # A literal representation of the hash
=> {"last_name"=>"Hartl", "first_name"=>"Michael"}

>> # hash literal representation
>> user = { "first_name" => "Michael", "last_name" => "Hartl" }
=> {"last_name"=>"Hartl", "first_name"=>"Michael"}

>> # symbol examples
>> "name".split('')
=> ["n", "a", "m", "e"]
>> :name.split('')
NoMethodError: undefined method `split' for :name:Symbol
>> "foobar".reverse
=> "raboof"
>> :foobar.reverse
NoMethodError: undefined method `reverse' for :foobar:Symbol
>> user = { :name => "Michael Hartl", :email => "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> user[:name]              # Access the value corresponding to :name.
=> "Michael Hartl"
>> user[:password]          # Access the value of an undefined key.
=> nil

>> # symbol and hashrocket combination 
>> h1 = { :name => "Michael Hartl", :email => "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> h2 = { name: "Michael Hartl", email: "michael@example.com" }
=> {:name=>"Michael Hartl", :email=>"michael@example.com"}
>> h1 == h2
=> true

>> # nested hashes
>> params = {}        # Define a hash called 'params' (short for 'parameters').
=> {}
>> params[:user] = { name: "Michael Hartl", email: "mhartl@example.com" }
=> {:name=>"Michael Hartl", :email=>"mhartl@example.com"}
>> params
=> {:user=>{:name=>"Michael Hartl", :email=>"mhartl@example.com"}}
>>  params[:user][:email]
=> "mhartl@example.com"

>> # each on hashes with inspect method calls
>> flash = { success: "It worked!", danger: "It failed." }
=> {:success=>"It worked!", :danger=>"It failed."}
>> flash.each do |key, value|
?>   puts "Key #{key.inspect} has value #{value.inspect}"
>> end
Key :success has value "It worked!"
Key :danger has value "It failed."

>> # more inspect calls
>> puts (1..5).to_a            # Put an array as a string.
1
2
3
4
5
>> puts (1..5).to_a.inspect    # Put a literal array.
[1, 2, 3, 4, 5]
>> puts :name, :name.inspect
name
:name
>> puts "It worked!", "It worked!".inspect
It worked!
"It worked!"

>> # inspect shortcut
p :name             # Same output as 'puts :name.inspect'
:name
#+END_SRC

CSS revisited. \\
In Ruby, parentheses are optional during function calls. When hashes
are the /last/ argument in a function call, the curly braces are
optional. Ruby interprets it correctly because, Ruby doesn't
distinguish between newlines and other whitespace in this
context. Breaking the lines with whitespace helps in readability. \\
The =stylesheet_link_tag= function is called with two arguments:
- a string indicating the path to the stylesheet
- a hash with two elements, indicating the media type and telling
  Rails to use the turbolinks feature
Because of the ERb, the results are inserted into the template of the
ERb. 

#+BEGIN_SRC ruby
# Parentheses on function calls are optional.
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')
stylesheet_link_tag 'application', media: 'all',
                                   'data-turbolinks-track': 'reload'
# Curly braces on final hash arguments are optional.
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }
#+END_SRC

*Ruby classes*. \\
Ruby uses /classes/ to organize methods; these classes are than
/instantiated/ to create objects. \\
Constructors. We instantiated a string using the double quote
characters, i.e a literal constructor for strings. But we can also use
the =new= keyword on the class name itself to instantiate an
object. Arrays work the same way; they accept a literal array. Hashes,
in contrast to =Array.new=, take a default value for the hash, which
will be the value for nonexistent keys. \\
When a method gets called on the class itslef (e.g =new=), then it is
a /class method/. A method call on an instance (e.g. =length= on an
array) is an /instance method/.  
#+BEGIN_SRC ruby
>> s = String.new("foobar")   # A named constructor for a string
=> "foobar"
>> s.class
=> String
>> s == "foobar"
=> true
>> a = Array.new([1, 3, 2])
=> [1, 3, 2]
>> h = Hash.new
=> {}
>> h[:foo]            # Try to access the value for the nonexistent key :foo.
=> nil
>> h = Hash.new(0)    # Arrange for nonexistent keys to return 0 instead of nil.
=> {}
>> h[:foo]
=> 0
#+END_SRC

Class inheritance. \\
The =class= and =superclass= methods are useful to find out the class
hierarchy. If you trace back the class hierarchy far enough then every
class in Ruby ultimately inherits from =BasicObject=, which has no
superclass itself. This is the technical meaning of "everything in
Ruby is an object". 
#+BEGIN_SRC ruby
>> s = String.new("foobar")
=> "foobar"
>> s.class                        # Find the class of s.
=> String
>> s.class.superclass             # Find the superclass of String.
=> Object
>> s.class.superclass.superclass  # Ruby 1.9 uses a new BasicObject base class
=> BasicObject
>> s.class.superclass.superclass.superclass
=> nil

>> class Word < String             # Word inherits from String.
>>   # Returns true if the string is its own reverse.
>>   def palindrome?
>>     self == self.reverse        # self is the string itself.
>>   end
>> end
=> nil
>> s = Word.new("level")    # Make a new Word, initialized with "level".
=> "level"
>> s.palindrome?            # Words have the palindrome? method.
=> true
>> s.length                 # Words also inherit all the normal string methods.
=> 5
>> s.class
=> Word
>> s.class.superclass
=> String
>> s.class.superclass.superclass
=> Object
#+END_SRC

Modify built-in classes. \\
While inheritance is a powerful idea, in the case of palindrome it
might be more natural to add the =palindrome?= method to the =String=
class itself, so we can use it on a string literal. Modifying built-in
classes is a powerful technique, but its considered bad form to add
methods to built-in classes without having a /really good/ reason for
doing so. \\
In Rails, web apps often want to prevent variables from being
blank--e.g a user's name should be something other than whitespace, so
rails adds the =blank?= method to Ruby. \\
The =self= keyword does not need to be used when dealing with
classes. =self= may be removed and all method calls in the function
weill be done on the instance. 
#+BEGIN_SRC ruby
>> "level".palindrome?
NoMethodError: undefined method `palindrome?' for "level":String
>> class String
>>   # Returns true if the string is its own reverse.
>>   def palindrome?
>>     self == self.reverse
>>   end
>> end
=> nil
>> "deified".palindrome?
=> true

>> # Rails adds the blank? method to Ruby
>> "".blank?
=> true
>> "      ".empty?
=> false
>> "      ".blank?
=> true
>> nil.blank?
=> true
>> nil.empty?
NoMethodError: undefined method `empty?' for nil:NilClass

>> class String
>>   def shuffle
>>     self.split('').d=shuffle.join
>>   end
>> end
>> "foobar".shuffle
=> "borafo"

>> # is the same as 
>> class String
>>   def shuffle
>>     split('').shuffle.join
>>   end
>> end
>> "foobar".shuffle
=> "borafo"
#+END_SRC

A controller class. \\
When call the =home= method on the instantiated
=StaticPagesController= object, we get a value of nil. The point of
the =home= action is to render a web page, not to return a
value. Rails is written in Ruby, but Rails is not Ruby. Some Rails
classes are used like ordinary Ruby objects. Rails is its own thing
and should be studied seperately from Ruby.
#+BEGIN_SRC ruby
>> controller = StaticPagesController.new
=> #<StaticPagesController:0x22855d0>
>> controller.class
=> StaticPagesController
>> controller.class.superclass
=> ApplicationController
>> controller.class.superclass.superclass
=> ActionController::Base
>> controller.class.superclass.superclass.superclass
=> ActionController::Metal
>> controller.class.superclass.superclass.superclass.superclass
=> AbstractController::Base
>> controller.class.superclass.superclass.superclass.superclass.superclass
=> Object

>> controller.home
=> nil
#+END_SRC

A user class. \\
In Rails, the principal importance of instance variables is that they
are automatically available in the views. \\
In general they are used for variables that need to be available
throughout a Ruby class. \\
Initializing objects using a hash argument is a technique known as
/mass assignment/ (cf ch7). 
- =attr_accessor= creates /attribute accessors/ corresponding to a
  user's name and email address. This creates "getter" and "setter"
  methods that allow us to retrieve (get) and assing (set) =@name= and
  =@email= instance variables.
- =def initialize= is special in Ruby: it's the method called when we
  execute =User.new=.
- =attributes = {}=: the attributes variable has a /default value/ equal to
  the empty hash, so that we can define a user with no name or email
  address.
  - Recall: hashes return =nil= for nonexistent keys, so
    =attributes[:name]= will be =nil= and =attributes[:email]= will be
    =nil=.
#+BEGIN_SRC ruby
class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end

  def formatted_email
    "#{@name} <#{@email}>"
  end
end

>> require './example_user'     # This is how you load the example_user code.
=> true
>> example = User.new
=> #<User:0x224ceec @email=nil, @name=nil>
>> example.name                 # nil since attributes[:name] is nil
=> nil
>> example.name = "Example User"           # Assign a non-nil name
=> "Example User"
>> example.email = "user@example.com"      # and a non-nil email address
=> "user@example.com"
>> example.formatted_email
=> "Example User <user@example.com>"

>> # we can omit the curly braces for final hash arguments
>> user = User.new(name: "Michael Hartl", email: "mhartl@example.com")
=> #<User:0x225167c @email="mhartl@example.com", @name="Michael Hartl">
>> user.formatted_email
=> "Michael Hartl <mhartl@example.com>"
#+END_SRC
* Filling in the layout
Objectives:
- fill in the custom stylesheet
- fill in layout with links to the pages (such as Home and About)
- learn about partials, Rails routes, asset pipeline, and Sass
- user sign up functionality
Most of the changes deal with add/editing markup of the sample apps
layout, which (based on our testing guidelines) is exactly the kind of
work that we wouldn't ordinarily test-drive, or even test at all. Most
of the time will be in the editor and browser. We will write our first
/integration test/ to check the links on the final layout are
correct. 

*Adding some structure*. \\
We use CSS, Bootstrap, and partials to create a tidy layout. Its
useful to get a high-level overview of the UI as early as possible;
for that we use /mockups/ (in context of webapps: /wireframes), which
are rough sketches of what the eventual app will look like. \\


*Sass and the asset pipeline*. \\
The /asset pipeline/ simplifies the production and management of
static assets. 

The asset pipeline. \\
From the perspective of a typical Rails developer, there are three
main features to understand about the asset pipeline:
- asset directories: three standard directories for static
  assets. Each of these directories has a subdirectory for each asset
  class: images, JS, CSS.
  - =app/assets=: assets specific to the present app
  - =lib/assets=: assets for libraries written by our developer team
  - =vendor/assets=: assets from third party developers
- manifest files: after placing the assets in their logical locations,
  manifest files tell Rails (via Sprockets gem) how to combine them to
  form a single file. We won't need to make any changes, but see the
  Rails Guides entry on the asset pipeline for more details. Consider
  the =application.css= as an   example. The CSS comments are used by
  Sprockets to include the proper files:
  - '*= require_tree': ensures that all CSS files in the
    =app/assets/stylesheets= dir (including tree subdirs) are included
    in the application CSS.
  - '*= require_self': specifies where in the loading sequence the CSS
    in =application.css= itself gets included. 
- preprocessor engines: after you assembled your assets, Rails
  prepares them for the site template by running them through several
  preprocessing engines and using the manifest files to combine them
  for delivery to the browser. We tell Rails which processor to use
  using the filename extensions =.scss=,  =.coffee=, or =.erb=. The
  preprocessor engines can be chained, so that =foobar.js.erb.coffee=
  get run through both CoffeeScript and ERb (code from right to left).

Efficiency in production. \\
The asset pipeline results in assets that are optimized to be
efficient in a production application. Traditional methods for
organizing CSS and JS involve splitting functionality into seperate
files and using nice formatting (convenient for programmers,
inefficient for production). In particular, multiple full-sized files
can significantly slow page-load times. With the asset pipeline, we
don't have to choose between speed and convenience: we can work with
multiple nicely formated files in dev, and then use the asset pipeline
to make efficient files in production. In particular the asset
pipeline combines all the: 
- application stylesheets into one CSS file (=application.css=),
- application JS into one JS file (=application.js=),
and then minifies them to remove the unnecessary spacing and
indentation that bloats the file size.

Syntactically awesome stylesheets. \\
Sass is a language for writing stylesheets that improves on CSS. We
cover two improvements:
- nesting: nested elements can inherit from enclosing parent
  element. To reference the parent element (e.g =#logo= on hover),
  we use an =&= (cf. below) to get =&:hover= (converted by SCSS to
  =#logo:hover=). 
- variables: eliminate duplication and write more expressive code. Its
  often useful to define variables even for values that aren't
  repeated. 
- mixins (cf. ch7)
Sass supports a format called SCSS, which is a superset of CSS
itself. Consequently, every CSS file is also a valid SCSS file, which
is convenient for projects with existing style rules. Since the Rails
asset pipeline automatically uses Sass to process files with the
=.scss= extension, the =custom.scss= file will be run through the Sass
preprocessor before being packaged up for delivery to the browser. 

SCSS nesting examples.
#+BEGIN_SRC css
// CSS
.center {
  text-align: center;
}
.center h1 {
  margin-bottom: 10px;
}

// CSS hover attribute
#logo {
  ...
}
#logo:hover {
  ...
}


// SCSS
.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

// SCSS hover attribute
#logo {
  ...
  &:hover {
    ...
  }
}
#+END_SRC

SCSS variable declaration examples.
#+BEGIN_SRC css
// CSS: multiple declarations of the same attributes
h2 {
  ...
  color: #777;
}
...
footer {
  ...
  color: #777;
}

// SCSS: defining variables
$light-gray: #777;
...
h2 {
  ...
  color: $light-gray;
}
...
footer {
  ...
  color: $light-gray;
}
#+END_SRC


Rails routes. \\
To add the named routes for the sample app's static pages, we'll edit
the routes file, =config/routes.rb=, that Rails uses to define URL
mappings. We'll begin by reviewing the route for the Home page, which
is a special case, and then define a set of routes for the remaining
static pages. Root route definition (controller#action) :
 : root 'static_pages#home'
Defining the root route creates a named route that allows us to refer
to routes by names other than the raw URL. 
- =root_path= -> '/'
- =root_url=  -> 'http://www.example.com'
We use =_path= for all but redirects, in which case, we use =_url= as
specified in the HTTP standard. We redefine the verbose
=static_pages/...= routes to shorter ones:
 : get 'static_pages/help'
 : get '/help', to: 'static_pages#help'


Using named routes. \\

Layout link tests. \\
After filling several of the layout links, it's a good idea to test
them to make sure they're working correctly. We could do this by hand
with a browser: visit the root path then check the links by hand.
This quickly becomes combersome. Instead, we simulate the same series
of steps using an /integration test/.
=$ rails generate integration_test site_layout=
Our plan for testing the layout links involves checking the HTML
structure of our site:
1) get the root path (Home page)
2) verify the right page template is rendered
3) check for the correct link to the Home, Help, About, and Contact
   pages
Below we use some of the more advanced options of the =assert_select=
method. We use the syntax that allows us to test for the presence of a
particular link-URL combination by specifying the tag name =a= and
attribute =href=. Rails automatically inserts the value of (say) the
=about_path= in place of the question (escaping special characters) to
get the tag <a href"/about">...</a>. The assertion of the root path
verifies there are two such links (the logo and navigation menu
element). \\
Below are more uses of =assert_select=. While =assert_select= is flexible
and powerful (having many more options than shown here), experience
shows that it's wise to take a lightweight approach to testing only
HTML elements (such as site layout links) that are unlikely to change
much over time. 
#+BEGIN_SRC ruby
  test "layout links" do
    get root_path
    assert_template 'static_pages/home'
    assert_select "a[href=?]", root_path, count: 2
    assert_select "a[href=?]", help_path
    assert_select "a[href=?]", about_path
    assert_select "a[href=?]", contact_path
  end
#+END_SRC
| Code                                        | Matching HTML                  |
|---------------------------------------------+--------------------------------|
| assert_select "div"                         | <div>foobar</div>              |
| assert_select "div", "foobar"               | <div>foobar</div>              |
| assert_select "div.nav"                     | <div class="nav">foobar</div>  |
| assert_select "div#profile"                 | <div id="profile">foobar</div> |
| assert_select "div[name=yo]"                | <div name="yo">hey</div>       |
| assert_select "a[href=?]", '/', count: 1    | <a href="/">foo</a>            |
| assert_select "a[href=?]", '/', text: "foo" | <a href="/">foo</a>            |


*User signup: a first step*. \\
We will make a route for the singup page and create a second
controller. There are three steps for representing users on the sample
app site:
1) layout and routing of the signup page (here)
2) modeling users (ch6)
3) user registration and account activation (ch7)

User controller. \\
 : $ rails generate controller Users new
We =generate= the simplest controller that meets our needs, viz one
with a stub signup page for new users. Following REST, we'll call the
action for new users =new=. \\
The result creates a Users controller with a =new= action, a stub for
a user view, a minimal test for the new user page, and the routing. 

On multiple assertions in single test. \\
Some developers insist that a single test shouldn’t contain multiple
assertions. I find this practice to be unnecessarily complicated,
while also incurring an extra overhead if there are common setup tasks
needed before each test. In addition, a well-written test tells a
coherent story, and breaking it up into individual pieces disrupts the
narrative. I thus have a strong preference for including multiple
assertions in a test, relying on Ruby (via minitest) to tell me the
exact lines of any failed assertions. 

What we learned in this chapter
- Using HTML5, we can define a site layout with logo, header, footer, and main body content.
- Rails partials are used to place markup in a separate file for convenience.
- CSS allows us to style the site layout based on CSS classes and ids.
- The Bootstrap framework makes it easy to make a nicely designed site quickly.
- Sass and the asset pipeline allow us to eliminate duplication in our CSS while packaging up the results efficiently for production.
- Rails allows us to define custom routing rules, thereby providing named routes.
- Integration tests effectively simulate a browser clicking from page to page. 
* Modeling users
- we create a /data model/ for users of our site, together with a way
  to store that data
- ch7- give users the ability to sign up for our site and create a
  user and profile page
- ch8 and ch9- let them log in and log out as well
- ch10- protect pages from improper access
- ch11 and ch12- add account activations (thereby confirming valid
  email) and password resets

Rolling our own authentication system. \\
Virtually all web apps require a login and authentication system of
some sort. Most web frameworks (Rails included) have a plethora of
authentication and authorization systems (Clearance, Authlogic,
Device, CanCan and non-Rails-specific solutions built on OpenID or
OAuth). Why reinvent the wheel? \\
Authentication on most sites requires extensive
customization. Mofifying a third-party product is often more work than
writing the system from scratch. Also, off-the-shelf systems can be
"black boxes". Writing our own helps us understand (and provides the
ability to modify) the internals of others.

*User model*. \\
Although ultimate goal is to create a signup page for our site. Before
we accept information from users, we must create data structures to
capture and store it. \\
We are dealing with the M in MVC. The default Rails solution the
problem of persistence is to use a /database/ for long-term data
storage. The default library for interacting with the database is
/Active Record/. Active Record comes with a host of methods for
creating, saving, and finding data objects, all without having to use
the structured query language SQL. \\
Moreover, Rails has a feature called /migrations/ to allow data
definitions to be written in pure Ruby, without having to learn an SQL
DDL. In effect, Rails insulates you almost entirely from the details
of the database.

Database migrations. \\
Recall: we created a custom-built =User= class and created user
objects through the Rails console. That class served as a useful
example, but lacked the critical property of /persistence/: when we
created a User object it disappeared as soon as we exited the Rails
console. Our goal is to create a model to persist users data. \\
When using Rails to model users we don't need to identify the
attributes explicitly (Rails uses a RDB by default). 
 : We generated a Users controller with:
 : $ rails generate controller Users new
 : To generate a model, we use the analogous command
 : $ rails generate model User name:string email:string
Note. In contrast to the plural convention for controller names,
models names are singular: a Users controller, but a User model. \\
The result of the model generator is a migration file. Migrations
provide a means to alter the structure of the RDB incrementally. \\
The migration consists of a =change= method that determines the change
to be made to the database. The =create_table= method accepts a block
with one block variable, in this case called =t= for table. Inside the
block, the =create_table= method uses the =t= object to create =name=
and =email= columns in the database, both of type string. Here the
table name is plural, =users=, even though the model name is singular
=User=, reflecting the linguistic convention followed by Rails: 
- a model represents a single user
- a database table consists of many users.
=t.timestamps= creates two colums, =created_at= and =updated_at=,
which are timestamps for the record. \\
We run =rails db:migrate= to 'migrate up'. The first time its run, it
creates a file =db/development.sqlite3=, which is an SQLite
database. \\
Under the hood, this command executes the =drop_table= command to remove
the users table from the database. The reason this works is that the
change method knows that =drop_table= is the inverse of =create_table=,
which means that the rollback migration can be easily inferred. In the
case of an irreversible migration, such as one to remove a database
column, it is necessary to define separate up and down methods in
place of the single change method. Read about migrations in the Rails
Guides for more information.
#+BEGIN_SRC ruby
def change
    create_table :users do |t|
      t.string :name
      t.string :email

      t.timestamps
    end
#+END_SRC


Creating user objects. \\
=rails console --sandbox= for when we don't want to make any
changes. An class inheriting from Active Record also takes an
initialization hash to set the object attributes:
 : >> user = User.new(name: "Lupo Zen", email: "lzen@example.com")
 : => #<User id: nil, name: "Lupo Zen", email: "lzen@example.com", 
        created_at: nil, updated_at: nil>
 : >> user.valid?
 : true
Our =user= object is valid, as verified by calling the =valid?=
method (cf. below). So far we've only created the object in memory
(note the =id= column). We can use the =save= method to persist
objects from memory to the database. You can learn a lot by reading
by reading the SQL corresponding to Active Record commands. \\
The =create= method combins the =new= and =save= method to directly
persist. While =save= returns a boolean to determine if the user was
saved, =create= simply returns the user object back. The inverse is
the =destroy= method which also returns the object in question. The
destroyed object still exists in memory. \\
So how do we know if we really destroyed an object? And for saved and
non-destroyed objects, how can we retrieve users from the database? We
need to learn how to use Active Record to find user objects. 
#+BEGIN_SRC ruby
>> user.save
(0.4ms)  SAVEPOINT active_record_1
  SQL (0.8ms)  INSERT INTO "users" 
  ("name", "email", "created_at", "updated_at") 
  VALUES ($1, $2, $3, $4) RETURNING "id"  
  [["name", "Lupo Zen"], ["email", "lzen@example.com"], 
  ["created_at", 2016-08-19 23:43:33 UTC], 
  ["updated_at", 2016-08-19 23:43:33 UTC]]
   (0.3ms)  RELEASE SAVEPOINT active_record_1
=> true
>> user
=> #<User id: 1, name: "Lupo Zen", email: "lzen@example.com", 
  created_at: "2016-08-19 23:43:33", updated_at: "2016-08-19 23:43:33">
#+END_SRC

Finding user objects. \\
- =User.find(1)=: matches the id field of user records. 
- =User.find_by(email: "...")=: match specified column with
  specified paramter of a user record.
- =User.first= : first user of the database.
- =User.all= : returns all the users in the database as an object of
  class =ActiveRecord::Relation= (effectively an array).
- =user.reload= : reloads that in memory =user= object from the
  database copy. We can change the in memory copy and persist with
  =save=. In effect, reassigning is a way to update multiple attributes.
- =user.update_attributes(name: "...")= a second way to update
  multiple attributes. Returns boolean as sentinel value.

*User validations*. \\
The User model now has working =name= and =email= attributes, but they
are completely generic; any string will do. We will add validations
for =name= not to be blank, =email= should match the specific format
characteristic of email addresses. Moreover, since we'll be using
email addresses as unique usernames when users log in, we shouldn't
allow email duplicates in the database. \\
Active Record allows us to impose contraints on fields values using
/validations/. We cover the most common cases, validating /presence/,
/length/, /format/ and /uniqueness/. Later we cover /confirmation/. In
ch7 we'll see how validations give us convenient error messages when
users make submissions that violate them. 

A validity test. \\
Model validation is a perfect fit for TDD. It's difficult to be
confident that a given validation is doing exactly what we expec it to
without writing a failing test and then getting it to pass. \\
Our method:
- start with a /valid/ model object,
- set one of its attributes to something we want to be invalid,
- and test that it in fact is invalid.
As a safety net, we'll first write a test to make sure the initial
model object is valid. This way, when the validation tests fail we'll
know it's for the right reason (and not bc the initial object was
invalid in the first place). \\
To write a test for a valid object, we'll create an initially valid
User model object =@user= using the special =setup= method which
automatically gets run before each test. Bc =@user= is an instance
variable, it's automatically available in all the tests, and we can
test its validity using the =valid?= method. The =assert= method
succeeds if =@user.valid?= returns =true= and fails on =false=. \\
Since the =User= class has no =validates= methods, the model is
valid. 
#+BEGIN_SRC ruby
def setup
  @user = User.new(...)
end
test "should be valid" do
  assert @user.valid?
end
#+END_SRC

Validity presence. \\
/Presence/ simply verifies that a given attribute is present. We start
with a test for the presence of a =name= attribute:
- set the =@user= variable's =name= to a blank string
- check (via =assert_not=) that the resulting User object is not
  valid.
 : test "name should be present" do
 :   @user.name = "     "
 :   assert_not @user.valid?
 : end
Running =$ rails test:models= yields RED (failing). This is the
behavior we expect our model to follow, given a blank name, the
statement "assert that the model is not valid" should be true. We
augment the model object to make the statement true:
 : class User < ApplicationRecord
 :   validates :name, presence: true
 : end
Not only do the tests yield GREEN (pass), but we can also see this in
action using =$ rails console --sandbox=. Trying to save a model with
a blank no longer shows the SQL query, rather it displays a red
=ROLLBACK TO SAVEPOINT=. \\
=errors= displays the address of any associated errors with the
model. =errors.full_messages= displays the errors array with the
values of the errors. 

Same process should be followed for validating the presence of the
email attribute of the User model:
- write test statement for expected behavior (via =assert_not=) in the
  =UserTest=
 : test "email should be present" do
 :   @user.email = "     "
 :   assert_not @user.valid?
 : end
- run the test, see it fail (RED): =$ rails test:models=
- augment the model with intentions of providing expected behavior:
  =validates :email, presence: true=
- run the test, see it pass (GREEN): =$ rails test:models=

Length validation. \\
The user’s names will be displayed on the sample site, so we should
enforce some limit on their length.
 : test "name should not be long" do
 :   @user.name = "a" * 51  # over 50 is considered long
 :   assert_not @user.valid?
 : end
This test fails since the user has no length validation. We add length
validation to the user model:
 : validates :name, presence: true, length: { maximum: 50 }
=$ rails test:models= yields GREEN. 

Format validation. \\
The =email= attribute must satisfy more stringent requirements of
being a valid email address. So far, we've only reject blank email
addresses. Here, we require the email to conform to the familiar
pattern =user@example.com=. \\
Neither the test nor the validation will be exhaustive, just good
enough to accept most email addresses and reject most invaild
ones. Recall: the tests specify the behavior we expect. So the test
with the valid addresses are examples of what we expect to be valid
emails. The tests with invalid email address are examples of what we
expect to be invalid. We augment the model with the email validation
code that makes both these examples pass. In a way, we are defining
the boundary conditions of the correct and incorrect behavior of the
model, then implementing the least amount of functionality to make
these assertions examples pass.  \\
Bc email format validation is tricky and error-prone, we'll start with
passing tests for /valid/ email addresses to catch any errors in the
validation. \\
Remark: we can create an array of strings using the =%w[...]=
construct.Below we use =assert= with the second, optional, parameter as our
custom message. Recall: the interpolated =inspect= method returns the
value of the objects =to_s= method.
#+BEGIN_SRC ruby
test "email validation should accept valid addresses" do
  valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org
                       first.last@foo.jp alice+bob@baz.cn]
  valid_addresses.each do |valid_address|
    @user.email = valid_address
    assert @user.valid?, "#{valid_address.inspect} should be valid"
  end
end
test "email validation should not accept invalid addresses" do
  invalid_addresses = %w[user@example,com user_at_foo.org 
              user.name@example. foo@bar_baz.com foo@bar+baz.com ]
  invalid_addresses.each do |invalid_address|
    @user.email = invalid_address
    assert_not @user.valid? , "#{invalid_address.inspect} should be invalid"
  end
end
#+END_SRC
The application code for the email format validation uses the =format=
validation, which works like this: =validates :email, format: { with:
/<regexp>/ }=. Regular expressions are uses for matching patterns in
strings. Here, we use it to match valid email addresses while not
matching invalid ones. There exists a [[http://emailregex.com][full regex]] for matching email
addresses according to the [[http://www.ietf.org/rfc/rfc5322.txt][official email standard]], but it's enormous,
obscure, and possibly counter-productive. We'll adopt a pragmatic
regex that has proven to be robust in practice (see [[http://www.rubular.com/r/aE4zppL0TA][rublar]] leave off
the \A and \z characters so that you can match more than one email
address at a time in the given test string) : 
 : VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
| Expression                           | Meaning                                           |
| /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i | full regex                                        |
| /                                    | start of regex                                    |
| \A                                   | match start of a string                           |
| [\w+\-.]+                            | at least one word character, plus, hyphen, or dot |
| @                                    | literal “at sign”                                 |
| [a-z\d\-.]+                          | at least one letter, digit, hyphen, or dot        |
| \.                                   | literal dot                                       |
| [a-z]+                               | at least one letter                               |
| \z                                   | match end of a string                             |
| /                                    | end of regex                                      |
| i                                    | case-insensitive                                  |
Applying
