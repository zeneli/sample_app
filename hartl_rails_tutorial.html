<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>hartl_rails_tutorial</title>
<!-- 2016-09-19 Mon 02:00 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="az" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">hartl_rails_tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Software Design Process</a></li>
<li><a href="#sec-2">2. beginning</a></li>
<li><a href="#sec-3">3. Mostly Static Pages</a></li>
<li><a href="#sec-4">4. Rails-flavored Ruby</a></li>
<li><a href="#sec-5">5. Filling in the layout</a></li>
<li><a href="#sec-6">6. Modeling users</a></li>
<li><a href="#sec-7">7. Sign up</a></li>
<li><a href="#sec-8">8. Basic login</a></li>
<li><a href="#sec-9">9. Updating, showing, and deleting users</a>
<ul>
<li><a href="#sec-9-1">9.1. Updating users</a></li>
<li><a href="#sec-9-2">9.2. Authorization</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Software Design Process</h2>
<div class="outline-text-2" id="text-1">
<p>
Phases:
</p>
<ul class="org-ul">
<li>Problem Description
</li>
<li>Current Existing Solutions 
<ul class="org-ul">
<li>description of ineffectiveness of current solution
</li>
</ul>
</li>
</ul>
<p>
`  - Rationale Description 
</p>
<ul class="org-ul">
<li>Mission Statement
</li>
<li>BDD
<ul class="org-ul">
<li>SMART Stories
</li>
<li>Story Boards / Scenarios
</li>
</ul>
</li>
<li><b>Lo FI UI</b>
</li>
<li>Hypothesis
</li>
</ul>

<p>
Software Company.
</p>
<ul class="org-ul">
<li>RYAN Client- paper pencil. Doesnt know what a req is.
</li>
<li>ERV Meidator- create req 
</li>
<li>LUPO Software Officer- translate req
</li>
<li>Software Devs- write acceptance tests of req. And code. 
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> beginning</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>Version control with Git</b>. <br  />
Undoing things a la Git. <br  />
</p>
<ul class="org-ul">
<li>git status : everything is fine
</li>
<li>rm -rf app/controllers
</li>
<li>git status : D'oh!
</li>
<li>git checkout -f : undo the changes of the working tree by force
overwriting the current changes.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Mostly Static Pages</h2>
<div class="outline-text-2" id="text-3">
<p>
The application will eventually have users, microposts, and a full
login and authentication framework. <br  />
We begin with static pages, a highly instructive exercise, rich in
implications. We will get a first taste of automated testing, which
will help us be more confident that our code is correct. Moreover,
having a good test suite will allow us to <i>refactor</i> our code with
confidence, changing its form without changing its function. 
</p>

<p>
<b>Sample app setup Git</b>. <br  />
The commit and push sequence below is the kind of pattern that should
be followed in real-life development.
</p>
<ol class="org-ol">
<li>git checkout -b static-pages
</li>
<li>rails generate controller StaticPages home help
</li>
<li>git add -A
</li>
<li>git commit -m "Add a Static Pages controller"
</li>
<li>git push -u origin static-pages
</li>
<li>git push
</li>
</ol>

<p>
<b>Undoing things a la Rails</b>. <br  />
Controllers
</p>
<ol class="org-ol">
<li>rails generate controller StaticPages home help
</li>
<li>rails destroy controller StaticPages home help
</li>
</ol>
<p>
Models
</p>
<ol class="org-ol">
<li>rails generate model User name:string email:string
</li>
<li>rails destroy model User
</li>
</ol>
<p>
Migrations
</p>
<ol class="org-ol">
<li>rails db:migrate
</li>
<li>rails db:rollback    undo a single migration
</li>
<li>rails db:migrate VERSION=0    undo to the beginning
</li>
</ol>

<p>
<code>GET</code>. <br  />
HTTP defines the basic operations <code>GET</code>, <code>POST</code>, <code>PATCH</code>, and
<code>DELETE</code>. These refer to operations between a <i>client</i> computer and a
<i>server</i>. An emphasis on HTTP verbs is typical of web frameworks
influenced by the <i>REST architecture</i>.
</p>
<ul class="org-ul">
<li><code>GET</code>: used for <i>reading</i> data on the web
</li>
<li><code>POST</code>: the request sent by your browser when you submit a form
</li>
<li><code>PATCH</code>: updating
</li>
<li><code>DELETE</code>: destroying
</li>
</ul>
<p>
The last two are less common commong then <code>GET</code> and <code>POST</code> since
browsers are incapable of sending them natively, but web frameworks
(including Rails ) have clever ways of making it <i>seem</i> like 
browsers are issuing such request.
</p>

<p>
<b>Killing Spring server</b>. <br  />
Spring processes sometimes accumulate and slow performance of your
tests. If tests appear sluggish, its a good idea to inspect system
process and kill them if necessary. <br  />
</p>
<ul class="org-ul">
<li><code>ps aux</code>: display all process on system
</li>
<li><code>ps aux | grep spring</code>: display spring processes
</li>
<li><code>kill -15 pid</code>: issue Unix termination signal <code>-15</code> to kill process <code>pid</code>
</li>
<li><code>spring stop</code>: try stopping spring through its command
</li>
<li><code>pkill -15 -f spring</code>: if <code>spring stop</code> fails, then kill all
processes with name <code>spring</code>
</li>
</ul>

<p>
<b>Guard</b>. <br  />
The <code>rails test</code> command requires us to switch to the command line and
run the tests by hand. We can automate this behavior with Guard. Guard
monitors the filesystem so that, for example, when we change the
<code>static_pages_controller_test.rb</code> file, only those tess get run. Even
better, we can configure Guard so that when, say, the <code>home.html.erb</code>
file is modified, the <code>static_pages_controller_test.rb</code> automatically
runs. <br  />
</p>
<ol class="org-ol">
<li><code>bundle exec guard init</code> (one time setup step)
</li>
<li><code>bundle exec guard</code> automatically run tests
<ol class="org-ol">
<li>return to run all the tests
</li>
<li>Ctrl-D to exit
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Rails-flavored Ruby</h2>
<div class="outline-text-2" id="text-4">
<p>
<b>Motivation</b>. <br  />
Ruby is a big language, but the subset needed to be productive as a
Rails developer is relatively small. This chapter is designed to give
you a solid foundation in Rails-flavored Ruby. <br  />
</p>

<p>
Built-in helpers. <br  />
From <code>app/views/layouts/application.html.erb</code> we have a line
</p>
<div class="org-src-container">

<pre class="src src-ruby">&lt;%= stylesheet_link_tag 'application', media: 'all',
                                       'data-turbolinks-track': 'reload' %&gt;
</pre>
</div>
<p>
This uses the built-in Rails function <code>stylesheet_link_tag</code> to include
<code>application.css</code> for all media types. There are four Ruby ideas:
</p>
<ul class="org-ul">
<li>built-in Rails methods
</li>
<li>method invocation with missing parentheses
</li>
<li>symbols
</li>
<li>hashs
</li>
</ul>

<p>
Custom helpers. <br  />
Rails allows the cration of built-in functions called <i>helpers</i>. Its
good convention to have a <i>base tite</i> we use on every page, with an
optional page title if we want to be more specific. In the static
pages section, if we removed the <code>provide(:title, "...")</code> we would not
yield anything to the title tag. This problem can be solved with a
helper function <code>full_title</code>.
</p>
<div class="org-src-container">

<pre class="src src-ruby">module ApplicationHelper
  # Return the full title on a per-page basis.
  def full_title(page_title='')
    base_title = "Ruby on Rails Tutorial Sample App"
    if page_title.empty?
      base_title
    else
      page_title + " | " + base_title
    end
  end
end 

&lt;title&gt;&lt;%= full_title(yield(:title)) %&gt;&lt;/title&gt;
</pre>
</div>
<p>
The helper code above is full of Ruby ideas: modules, method
definition, optional method argument, comments, local variable
assignment, booleans, control flow, string concatenation, and return
values.
</p>

<p>
<b>Strings and methods</b>. <br  />
Our principal tool for learning Ruby will be the <i>Rails console</i>
(built on irb). The console is a great learning tool. 
</p>
<ul class="org-ul">
<li>Ctrl-C is you get stuck
</li>
<li>Ctrl-D to exit the console
</li>
</ul>

<p>
Strings are the most important data structure for web apps, since web
pages ultimately consist of strings of characters sent from the server
to the browser.
</p>
<ul class="org-ul">
<li>string literal: "foo"
</li>
<li>string concat: "foo" + "bar"
</li>
<li>string assign: first<sub>name</sub> = "Lupo"
</li>
<li>string interp: "#{first<sub>name</sub>} Zeneli", but not '#{first<sub>name</sub>} Zeneli'
</li>
</ul>
<p>
To <i>print</i> a string to the screen, the most commonly used Ruby
function is <code>puts</code>. The <code>puts</code> method operates as a <i>side-effect</i>: a
<code>puts</code> expression prints the argument to the screen then returns
<code>nil</code>. 
<code>print</code> prints the raw string without a newline char like <code>puts</code>. <br  />
</p>

<p>
Object and message passing. <br  />
Everything in Ruby is a an object; you have to build your intuition
for objects by seeing lots of examples. Its easier to describe what
objects do, i.e respond to messages. Messages that get passed to
objects are <i>methods</i>, which are functions defined on those
objects. <br  />
Ex: Strings respond to the <code>empty?</code> method. <br  />
<code>!!</code> coerces an object to its boolean value.
</p>

<p>
Note that Ruby functions have an <i>implicit return</i>, meaning they
return the last statement evaluated. So the following two definitions
of <code>string_message</code> are equivalent.
</p>
<div class="org-src-container">

<pre class="src src-ruby">def string_message(str='')
  if str.empty?
    "Its an empty string!"
  else
    "The string is nonempty."
  end
end

def string_message(str='')
  return "Its an empty string!" if str.empty?
  return "The string is nonempty."
</pre>
</div>
<p>
The second return of the second <code>string_message</code> function is
unnecessary&#x2013;being the last expression means it will be returned
regardless of the keyword <code>return</code>. In this case, we make the return
explicit for readability. <br  />
</p>
<pre class="example">
def palindrome_tester(s)
  if s == s.reverse
    puts "It's a palindrome!"
  else
    puts "It's not a palindrome."
  end
end
</pre>

<p>
Back to title helper. <br  />
</p>
<div class="org-src-container">

<pre class="src src-ruby">module ApplicationHelper
  # Returns the full title on a per-page basis.       # Documentation comment
  def full_title(page_title = '')                     # Method def, optional arg
    base_title = "Ruby on Rails Tutorial Sample App"  # Variable assignment
    if page_title.empty?                              # Boolean test
      base_title                                      # Implicit return
    else
      page_title + " | " + base_title                 # String concatenation
    end
  end
end
</pre>
</div>
<p>
Modules provide a way to package together related methods, which can
then be <i>mixed in</i> to Ruby classes using <code>include</code>. When writing
ordinary Ruby, you often write modules and include them explicitly
yourself. In the case of a helper module Rails handles the inclusion
for us. The result is that the <code>full_title</code> method is available in all
our views. 
</p>

<p>
<b>Other data structures</b>. <br  />
Web apps are ultimately about strings, but <i>making</i> those strings
requires other data structures as well. 
</p>

<p>
Arrays and ranges. <br  />
Understanding arrays provides a foundation for understanding hashes
and aspects of Rails data modeling (e.g <code>has_many</code> associations). Ruby
arrays are zero-offset. In additon to the conventional square bracket
syntax for accessing array elements, Ruby offers synonyms <code>first</code>,
<code>second</code>, and <code>last</code>. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; # split on defualt; space 
&gt;&gt;  "foo bar     baz".split     # Split a string into a three-element array.
=&gt; ["foo", "bar", "baz"]
&gt;&gt; # split on 'x'
&gt;&gt; "fooxbarxbazx".split('x')
=&gt; ["foo", "bar", "baz"]

&gt;&gt; # none of the methods change the array a
&gt;&gt; a
=&gt; [42, 8, 17]
&gt;&gt; a.empty?
=&gt; false
&gt;&gt; a.include?(42)
=&gt; true
&gt;&gt; a.sort
=&gt; [8, 17, 42]
&gt;&gt; a.reverse
=&gt; [17, 8, 42]
&gt;&gt; a.shuffle
=&gt; [17, 42, 8]
&gt;&gt; a
=&gt; [42, 8, 17]

&gt;&gt; # mutator methods of arrays ("bang" suffix)
&gt;&gt; a
=&gt; [42, 8, 17]
&gt;&gt; a.sort!
=&gt; [8, 17, 42]
&gt;&gt; a
=&gt; [8, 17, 42]

&gt;&gt; # push operations; arrays contain mixture of types
&gt;&gt; a.push(6)                  # Pushing 6 onto an array
=&gt; [42, 8, 17, 6]
&gt;&gt; a &lt;&lt; 7                     # Pushing 7 onto an array
=&gt; [42, 8, 17, 6, 7]
&gt;&gt; a &lt;&lt; "foo" &lt;&lt; "bar"        # Chaining array pushes
=&gt; [42, 8, 17, 6, 7, "foo", "bar"]

&gt;&gt; # join: inverse of split
&gt;&gt; a
=&gt; [42, 8, 17, 6, 7, "foo", "bar"]
&gt;&gt; a.join                       # Join on nothing.
=&gt; "4281767foobar"
&gt;&gt; a.join(', ')                 # Join on comma-space.
=&gt; "42, 8, 17, 6, 7, foo, bar"

&gt;&gt; # ranges to arrays via to_a
&gt;&gt; 0..9
=&gt; 0..9
&gt;&gt; 0..9.to_a              # Oops, call to_a on 9.
NoMethodError: undefined method `to_a' for 9:Fixnum
&gt;&gt; (0..9).to_a            # Use parentheses to call to_a on the range.
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt; # slicing: pulling out array elements
&gt;&gt; a = %w[foo bar baz quux]         # Use %w to make a string array.
=&gt; ["foo", "bar", "baz", "quux"]
&gt;&gt; a[0..2]
=&gt; ["foo", "bar", "baz"]
&gt;&gt; # slice to the end; -1 trick
&gt;&gt; a = (0..9).to_a
=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt; a[2..(a.length-1)]               # Explicitly use the array's length.
=&gt; [2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt; a[2..-1]                         # Use the index -1 trick.
=&gt; [2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt; # character ranges
&gt;&gt; ('a'..'e').to_a
=&gt; ["a", "b", "c", "d", "e"]
</pre>
</div>

<p>
Blocks. <br  />
Arrays and ranges respond to a host of methods that accept <i>blocks</i>.
<code>(1..5).each { |i| puts 2 * i }</code> calls the <code>each</code> method on the range
<code>(1..5)</code> and passes the block as an argument to <code>each</code>.  <code>|i|</code> is Ruby
syntax for a block varaible. In the Rails Tutorial we’ll follow the
common convention of using curly braces only for short one-line blocks
and the do..end syntax for longer one-liners and for multi-line
blocks. <br  />
To understand blocks, you have to see them a lot and eventually get
used to them. Below are a few examples that use the <code>map</code> method on
arrays and ranges. The <code>map</code> method returns the result of applying the
given block to each element of the array or range. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; (1..5).each do |i|
?&gt;   puts 2 * i
&gt;&gt; end
246810=&gt; 1..5
&gt;&gt; (1..5).each do |number|
?&gt;   print 2 * number
&gt;&gt;   print '--'
&gt;&gt; end
2--4--6--8--10--=&gt; 1..5

&gt;&gt; 3.times { puts "Betelgeuse!" }   # 3.times takes a block with no variables.
"Betelgeuse!"
"Betelgeuse!"
"Betelgeuse!"
=&gt; 3
&gt;&gt; (1..5).map { |i| i**2 }          # The ** notation is for 'power'.
=&gt; [1, 4, 9, 16, 25]
&gt;&gt; %w[a b c]                        # Recall that %w makes string arrays.
=&gt; ["a", "b", "c"]
&gt;&gt; %w[a b c].map { |char| char.upcase }
=&gt; ["A", "B", "C"]
&gt;&gt; %w[A B C].map { |char| char.downcase }
=&gt; ["a", "b", "c"]

&gt;&gt; # when calling a method of the variable use "symbol-to-proc"
&gt;&gt; %w[A B C].map { |char| char.downcase }
=&gt; ["a", "b", "c"]
&gt;&gt; %w[A B C].map(&amp;:downcase)
=&gt; ["a", "b", "c"]

&gt;&gt; # generate random subdomains
&gt;&gt; ('a'..'z').to_a                     # An alphabet array
=&gt; ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
&gt;&gt; ('a'..'z').to_a.shuffle             # Shuffle it.
=&gt; ["c", "g", "l", "k", "h", "z", "s", "i", "n", "d", "y", "u", "t", "j", "q",
"b", "r", "o", "f", "e", "w", "v", "m", "a", "x", "p"]
&gt;&gt; ('a'..'z').to_a.shuffle[0..7]       # Pull out the first eight elements.
=&gt; ["f", "w", "i", "a", "h", "p", "c", "x"]
&gt;&gt; ('a'..'z').to_a.shuffle[0..7].join  # Join them together to make one string.
=&gt; "mznpybuj"
</pre>
</div>

<p>
Hashes and symbols. <br  />
Hashes are indicated with curly braces containing key-value
pairs. Hashes doe not guarantee keeping elements in a particular
order. If order matters, use an array. hash value for an undefined key
is simply nil. <br  />
Although hashes can accept any object as a key, its more common to use
symbols. Symbols represent a single entity (rather then a set of
characters such as strings) so they are compared easily in O(1)
time. This makes them ideal as key representations. The
symbol/hashrocket construction follows the hash notation of other
languages (such as JS). <code>:name =&gt;</code> and <code>name:</code> are effectively the
same <i>only inside literal hashes</i>. <br  />
Hash values can be virtually anything, even other hashes (cf. code
below). These nested hashes are heavily used by Rails. Hashes (like
ranges and arrays) respond to the <code>each</code> method (cf. code below). <br  />
Note. <code>inspect</code> returns a string with a literal representation of the
object it's called on.
</p>

<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; user = {}                          # {} is an empty hash.
=&gt; {}
&gt;&gt; user["first_name"] = "Michael"     # Key "first_name", value "Michael"
=&gt; "Michael"
&gt;&gt; user["last_name"] = "Hartl"        # Key "last_name", value "Hartl"
=&gt; "Hartl"
&gt;&gt; user["first_name"]                 # Element access is like arrays.
=&gt; "Michael"
&gt;&gt; user                               # A literal representation of the hash
=&gt; {"last_name"=&gt;"Hartl", "first_name"=&gt;"Michael"}

&gt;&gt; # hash literal representation
&gt;&gt; user = { "first_name" =&gt; "Michael", "last_name" =&gt; "Hartl" }
=&gt; {"last_name"=&gt;"Hartl", "first_name"=&gt;"Michael"}

&gt;&gt; # symbol examples
&gt;&gt; "name".split('')
=&gt; ["n", "a", "m", "e"]
&gt;&gt; :name.split('')
NoMethodError: undefined method `split' for :name:Symbol
&gt;&gt; "foobar".reverse
=&gt; "raboof"
&gt;&gt; :foobar.reverse
NoMethodError: undefined method `reverse' for :foobar:Symbol
&gt;&gt; user = { :name =&gt; "Michael Hartl", :email =&gt; "michael@example.com" }
=&gt; {:name=&gt;"Michael Hartl", :email=&gt;"michael@example.com"}
&gt;&gt; user[:name]              # Access the value corresponding to :name.
=&gt; "Michael Hartl"
&gt;&gt; user[:password]          # Access the value of an undefined key.
=&gt; nil

&gt;&gt; # symbol and hashrocket combination 
&gt;&gt; h1 = { :name =&gt; "Michael Hartl", :email =&gt; "michael@example.com" }
=&gt; {:name=&gt;"Michael Hartl", :email=&gt;"michael@example.com"}
&gt;&gt; h2 = { name: "Michael Hartl", email: "michael@example.com" }
=&gt; {:name=&gt;"Michael Hartl", :email=&gt;"michael@example.com"}
&gt;&gt; h1 == h2
=&gt; true

&gt;&gt; # nested hashes
&gt;&gt; params = {}        # Define a hash called 'params' (short for 'parameters').
=&gt; {}
&gt;&gt; params[:user] = { name: "Michael Hartl", email: "mhartl@example.com" }
=&gt; {:name=&gt;"Michael Hartl", :email=&gt;"mhartl@example.com"}
&gt;&gt; params
=&gt; {:user=&gt;{:name=&gt;"Michael Hartl", :email=&gt;"mhartl@example.com"}}
&gt;&gt;  params[:user][:email]
=&gt; "mhartl@example.com"

&gt;&gt; # each on hashes with inspect method calls
&gt;&gt; flash = { success: "It worked!", danger: "It failed." }
=&gt; {:success=&gt;"It worked!", :danger=&gt;"It failed."}
&gt;&gt; flash.each do |key, value|
?&gt;   puts "Key #{key.inspect} has value #{value.inspect}"
&gt;&gt; end
Key :success has value "It worked!"
Key :danger has value "It failed."

&gt;&gt; # more inspect calls
&gt;&gt; puts (1..5).to_a            # Put an array as a string.
1
2
3
4
5
&gt;&gt; puts (1..5).to_a.inspect    # Put a literal array.
[1, 2, 3, 4, 5]
&gt;&gt; puts :name, :name.inspect
name
:name
&gt;&gt; puts "It worked!", "It worked!".inspect
It worked!
"It worked!"

&gt;&gt; # inspect shortcut
p :name             # Same output as 'puts :name.inspect'
:name
</pre>
</div>

<p>
CSS revisited. <br  />
In Ruby, parentheses are optional during function calls. When hashes
are the <i>last</i> argument in a function call, the curly braces are
optional. Ruby interprets it correctly because, Ruby doesn't
distinguish between newlines and other whitespace in this
context. Breaking the lines with whitespace helps in readability. <br  />
The <code>stylesheet_link_tag</code> function is called with two arguments:
</p>
<ul class="org-ul">
<li>a string indicating the path to the stylesheet
</li>
<li>a hash with two elements, indicating the media type and telling
Rails to use the turbolinks feature
</li>
</ul>
<p>
Because of the ERb, the results are inserted into the template of the
ERb. 
</p>

<div class="org-src-container">

<pre class="src src-ruby"># Parentheses on function calls are optional.
stylesheet_link_tag('application', media: 'all',
                                   'data-turbolinks-track': 'reload')
stylesheet_link_tag 'application', media: 'all',
                                   'data-turbolinks-track': 'reload'
# Curly braces on final hash arguments are optional.
stylesheet_link_tag 'application', { media: 'all',
                                     'data-turbolinks-track': 'reload' }
</pre>
</div>

<p>
<b>Ruby classes</b>. <br  />
Ruby uses <i>classes</i> to organize methods; these classes are than
<i>instantiated</i> to create objects. <br  />
Constructors. We instantiated a string using the double quote
characters, i.e a literal constructor for strings. But we can also use
the <code>new</code> keyword on the class name itself to instantiate an
object. Arrays work the same way; they accept a literal array. Hashes,
in contrast to <code>Array.new</code>, take a default value for the hash, which
will be the value for nonexistent keys. <br  />
When a method gets called on the class itslef (e.g <code>new</code>), then it is
a <i>class method</i>. A method call on an instance (e.g. <code>length</code> on an
array) is an <i>instance method</i>.  
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; s = String.new("foobar")   # A named constructor for a string
=&gt; "foobar"
&gt;&gt; s.class
=&gt; String
&gt;&gt; s == "foobar"
=&gt; true
&gt;&gt; a = Array.new([1, 3, 2])
=&gt; [1, 3, 2]
&gt;&gt; h = Hash.new
=&gt; {}
&gt;&gt; h[:foo]            # Try to access the value for the nonexistent key :foo.
=&gt; nil
&gt;&gt; h = Hash.new(0)    # Arrange for nonexistent keys to return 0 instead of nil.
=&gt; {}
&gt;&gt; h[:foo]
=&gt; 0
</pre>
</div>

<p>
Class inheritance. <br  />
The <code>class</code> and <code>superclass</code> methods are useful to find out the class
hierarchy. If you trace back the class hierarchy far enough then every
class in Ruby ultimately inherits from <code>BasicObject</code>, which has no
superclass itself. This is the technical meaning of "everything in
Ruby is an object". 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; s = String.new("foobar")
=&gt; "foobar"
&gt;&gt; s.class                        # Find the class of s.
=&gt; String
&gt;&gt; s.class.superclass             # Find the superclass of String.
=&gt; Object
&gt;&gt; s.class.superclass.superclass  # Ruby 1.9 uses a new BasicObject base class
=&gt; BasicObject
&gt;&gt; s.class.superclass.superclass.superclass
=&gt; nil

&gt;&gt; class Word &lt; String             # Word inherits from String.
&gt;&gt;   # Returns true if the string is its own reverse.
&gt;&gt;   def palindrome?
&gt;&gt;     self == self.reverse        # self is the string itself.
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; s = Word.new("level")    # Make a new Word, initialized with "level".
=&gt; "level"
&gt;&gt; s.palindrome?            # Words have the palindrome? method.
=&gt; true
&gt;&gt; s.length                 # Words also inherit all the normal string methods.
=&gt; 5
&gt;&gt; s.class
=&gt; Word
&gt;&gt; s.class.superclass
=&gt; String
&gt;&gt; s.class.superclass.superclass
=&gt; Object
</pre>
</div>

<p>
Modify built-in classes. <br  />
While inheritance is a powerful idea, in the case of palindrome it
might be more natural to add the <code>palindrome?</code> method to the <code>String</code>
class itself, so we can use it on a string literal. Modifying built-in
classes is a powerful technique, but its considered bad form to add
methods to built-in classes without having a <i>really good</i> reason for
doing so. <br  />
In Rails, web apps often want to prevent variables from being
blank&#x2013;e.g a user's name should be something other than whitespace, so
rails adds the <code>blank?</code> method to Ruby. <br  />
The <code>self</code> keyword does not need to be used when dealing with
classes. <code>self</code> may be removed and all method calls in the function
weill be done on the instance. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; "level".palindrome?
NoMethodError: undefined method `palindrome?' for "level":String
&gt;&gt; class String
&gt;&gt;   # Returns true if the string is its own reverse.
&gt;&gt;   def palindrome?
&gt;&gt;     self == self.reverse
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; "deified".palindrome?
=&gt; true

&gt;&gt; # Rails adds the blank? method to Ruby
&gt;&gt; "".blank?
=&gt; true
&gt;&gt; "      ".empty?
=&gt; false
&gt;&gt; "      ".blank?
=&gt; true
&gt;&gt; nil.blank?
=&gt; true
&gt;&gt; nil.empty?
NoMethodError: undefined method `empty?' for nil:NilClass

&gt;&gt; class String
&gt;&gt;   def shuffle
&gt;&gt;     self.split('').d=shuffle.join
&gt;&gt;   end
&gt;&gt; end
&gt;&gt; "foobar".shuffle
=&gt; "borafo"

&gt;&gt; # is the same as 
&gt;&gt; class String
&gt;&gt;   def shuffle
&gt;&gt;     split('').shuffle.join
&gt;&gt;   end
&gt;&gt; end
&gt;&gt; "foobar".shuffle
=&gt; "borafo"
</pre>
</div>

<p>
A controller class. <br  />
When call the <code>home</code> method on the instantiated
<code>StaticPagesController</code> object, we get a value of nil. The point of
the <code>home</code> action is to render a web page, not to return a
value. Rails is written in Ruby, but Rails is not Ruby. Some Rails
classes are used like ordinary Ruby objects. Rails is its own thing
and should be studied seperately from Ruby.
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; controller = StaticPagesController.new
=&gt; #&lt;StaticPagesController:0x22855d0&gt;
&gt;&gt; controller.class
=&gt; StaticPagesController
&gt;&gt; controller.class.superclass
=&gt; ApplicationController
&gt;&gt; controller.class.superclass.superclass
=&gt; ActionController::Base
&gt;&gt; controller.class.superclass.superclass.superclass
=&gt; ActionController::Metal
&gt;&gt; controller.class.superclass.superclass.superclass.superclass
=&gt; AbstractController::Base
&gt;&gt; controller.class.superclass.superclass.superclass.superclass.superclass
=&gt; Object

&gt;&gt; controller.home
=&gt; nil
</pre>
</div>

<p>
A user class. <br  />
In Rails, the principal importance of instance variables is that they
are automatically available in the views. <br  />
In general they are used for variables that need to be available
throughout a Ruby class. <br  />
Initializing objects using a hash argument is a technique known as
<i>mass assignment</i> (cf ch7). 
</p>
<ul class="org-ul">
<li><code>attr_accessor</code> creates <i>attribute accessors</i> corresponding to a
user's name and email address. This creates "getter" and "setter"
methods that allow us to retrieve (get) and assing (set) <code>@name</code> and
<code>@email</code> instance variables.
</li>
<li><code>def initialize</code> is special in Ruby: it's the method called when we
execute <code>User.new</code>.
</li>
<li><code>attributes = {}</code>: the attributes variable has a <i>default value</i> equal to
the empty hash, so that we can define a user with no name or email
address.
<ul class="org-ul">
<li>Recall: hashes return <code>nil</code> for nonexistent keys, so
<code>attributes[:name]</code> will be <code>nil</code> and <code>attributes[:email]</code> will be
<code>nil</code>.
</li>
</ul>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-ruby">class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end

  def formatted_email
    "#{@name} &lt;#{@email}&gt;"
  end
end

&gt;&gt; require './example_user'     # This is how you load the example_user code.
=&gt; true
&gt;&gt; example = User.new
=&gt; #&lt;User:0x224ceec @email=nil, @name=nil&gt;
&gt;&gt; example.name                 # nil since attributes[:name] is nil
=&gt; nil
&gt;&gt; example.name = "Example User"           # Assign a non-nil name
=&gt; "Example User"
&gt;&gt; example.email = "user@example.com"      # and a non-nil email address
=&gt; "user@example.com"
&gt;&gt; example.formatted_email
=&gt; "Example User &lt;user@example.com&gt;"

&gt;&gt; # we can omit the curly braces for final hash arguments
&gt;&gt; user = User.new(name: "Michael Hartl", email: "mhartl@example.com")
=&gt; #&lt;User:0x225167c @email="mhartl@example.com", @name="Michael Hartl"&gt;
&gt;&gt; user.formatted_email
=&gt; "Michael Hartl &lt;mhartl@example.com&gt;"
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Filling in the layout</h2>
<div class="outline-text-2" id="text-5">
<p>
Objectives:
</p>
<ul class="org-ul">
<li>fill in the custom stylesheet
</li>
<li>fill in layout with links to the pages (such as Home and About)
</li>
<li>learn about partials, Rails routes, asset pipeline, and Sass
</li>
<li>user sign up functionality
</li>
</ul>
<p>
Most of the changes deal with add/editing markup of the sample apps
layout, which (based on our testing guidelines) is exactly the kind of
work that we wouldn't ordinarily test-drive, or even test at all. Most
of the time will be in the editor and browser. We will write our first
<i>integration test</i> to check the links on the final layout are
correct. 
</p>

<p>
<b>Adding some structure</b>. <br  />
We use CSS, Bootstrap, and partials to create a tidy layout. Its
useful to get a high-level overview of the UI as early as possible;
for that we use <i>mockups</i> (in context of webapps: /wireframes), which
are rough sketches of what the eventual app will look like. <br  />
</p>


<p>
<b>Sass and the asset pipeline</b>. <br  />
The <i>asset pipeline</i> simplifies the production and management of
static assets. 
</p>

<p>
The asset pipeline. <br  />
From the perspective of a typical Rails developer, there are three
main features to understand about the asset pipeline:
</p>
<ul class="org-ul">
<li>asset directories: three standard directories for static
assets. Each of these directories has a subdirectory for each asset
class: images, JS, CSS.
<ul class="org-ul">
<li><code>app/assets</code>: assets specific to the present app
</li>
<li><code>lib/assets</code>: assets for libraries written by our developer team
</li>
<li><code>vendor/assets</code>: assets from third party developers
</li>
</ul>
</li>
<li>manifest files: after placing the assets in their logical locations,
manifest files tell Rails (via Sprockets gem) how to combine them to
form a single file. We won't need to make any changes, but see the
Rails Guides entry on the asset pipeline for more details. Consider
the <code>application.css</code> as an   example. The CSS comments are used by
Sprockets to include the proper files:
<ul class="org-ul">
<li>'*= require<sub>tree'</sub>: ensures that all CSS files in the
<code>app/assets/stylesheets</code> dir (including tree subdirs) are included
in the application CSS.
</li>
<li>'*= require<sub>self'</sub>: specifies where in the loading sequence the CSS
in <code>application.css</code> itself gets included. 
</li>
</ul>
</li>
<li>preprocessor engines: after you assembled your assets, Rails
prepares them for the site template by running them through several
preprocessing engines and using the manifest files to combine them
for delivery to the browser. We tell Rails which processor to use
using the filename extensions <code>.scss</code>,  <code>.coffee</code>, or <code>.erb</code>. The
preprocessor engines can be chained, so that <code>foobar.js.erb.coffee</code>
get run through both CoffeeScript and ERb (code from right to left).
</li>
</ul>

<p>
Efficiency in production. <br  />
The asset pipeline results in assets that are optimized to be
efficient in a production application. Traditional methods for
organizing CSS and JS involve splitting functionality into seperate
files and using nice formatting (convenient for programmers,
inefficient for production). In particular, multiple full-sized files
can significantly slow page-load times. With the asset pipeline, we
don't have to choose between speed and convenience: we can work with
multiple nicely formated files in dev, and then use the asset pipeline
to make efficient files in production. In particular the asset
pipeline combines all the: 
</p>
<ul class="org-ul">
<li>application stylesheets into one CSS file (<code>application.css</code>),
</li>
<li>application JS into one JS file (<code>application.js</code>),
</li>
</ul>
<p>
and then minifies them to remove the unnecessary spacing and
indentation that bloats the file size.
</p>

<p>
Syntactically awesome stylesheets. <br  />
Sass is a language for writing stylesheets that improves on CSS. We
cover two improvements:
</p>
<ul class="org-ul">
<li>nesting: nested elements can inherit from enclosing parent
element. To reference the parent element (e.g <code>#logo</code> on hover),
we use an <code>&amp;</code> (cf. below) to get <code>&amp;:hover</code> (converted by SCSS to
<code>#logo:hover</code>). 
</li>
<li>variables: eliminate duplication and write more expressive code. Its
often useful to define variables even for values that aren't
repeated. 
</li>
<li>mixins (cf. ch7)
</li>
</ul>
<p>
Sass supports a format called SCSS, which is a superset of CSS
itself. Consequently, every CSS file is also a valid SCSS file, which
is convenient for projects with existing style rules. Since the Rails
asset pipeline automatically uses Sass to process files with the
<code>.scss</code> extension, the <code>custom.scss</code> file will be run through the Sass
preprocessor before being packaged up for delivery to the browser. 
</p>

<p>
SCSS nesting examples.
</p>
<div class="org-src-container">

<pre class="src src-css">// CSS
.center {
  text-align: center;
}
.center h1 {
  margin-bottom: 10px;
}

// CSS hover attribute
#logo {
  ...
}
#logo:hover {
  ...
}


// SCSS
.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

// SCSS hover attribute
#logo {
  ...
  &amp;:hover {
    ...
  }
}
</pre>
</div>

<p>
SCSS variable declaration examples.
</p>
<div class="org-src-container">

<pre class="src src-css">// CSS: multiple declarations of the same attributes
h2 {
  ...
  color: #777;
}
...
footer {
  ...
  color: #777;
}

// SCSS: defining variables
$light-gray: #777;
...
h2 {
  ...
  color: $light-gray;
}
...
footer {
  ...
  color: $light-gray;
}
</pre>
</div>


<p>
Rails routes. <br  />
To add the named routes for the sample app's static pages, we'll edit
the routes file, <code>config/routes.rb</code>, that Rails uses to define URL
mappings. We'll begin by reviewing the route for the Home page, which
is a special case, and then define a set of routes for the remaining
static pages. Root route definition (controller#action) :
</p>
<pre class="example">
root 'static_pages#home'
</pre>
<p>
Defining the root route creates a named route that allows us to refer
to routes by names other than the raw URL. 
</p>
<ul class="org-ul">
<li><code>root_path</code> -&gt; '/'
</li>
<li><code>root_url</code>  -&gt; 'http://www.example.com'
</li>
</ul>
<p>
We use <code>_path</code> for all but redirects, in which case, we use <code>_url</code> as
specified in the HTTP standard. We redefine the verbose
<code>static_pages/...</code> routes to shorter ones:
</p>
<pre class="example">
get 'static_pages/help'
get '/help', to: 'static_pages#help'
</pre>


<p>
Using named routes. <br  />
</p>

<p>
Layout link tests. <br  />
After filling several of the layout links, it's a good idea to test
them to make sure they're working correctly. We could do this by hand
with a browser: visit the root path then check the links by hand.
This quickly becomes combersome. Instead, we simulate the same series
of steps using an <i>integration test</i>.
<code>$ rails generate integration_test site_layout</code>
Our plan for testing the layout links involves checking the HTML
structure of our site:
</p>
<ol class="org-ol">
<li>get the root path (Home page)
</li>
<li>verify the right page template is rendered
</li>
<li>check for the correct link to the Home, Help, About, and Contact
pages
</li>
</ol>
<p>
Below we use some of the more advanced options of the <code>assert_select</code>
method. We use the syntax that allows us to test for the presence of a
particular link-URL combination by specifying the tag name <code>a</code> and
attribute <code>href</code>. Rails automatically inserts the value of (say) the
<code>about_path</code> in place of the question (escaping special characters) to
get the tag &lt;a href"/about"&gt;&#x2026;&lt;/a&gt;. The assertion of the root path
verifies there are two such links (the logo and navigation menu
element). <br  />
Below are more uses of <code>assert_select</code>. While <code>assert_select</code> is flexible
and powerful (having many more options than shown here), experience
shows that it's wise to take a lightweight approach to testing only
HTML elements (such as site layout links) that are unlikely to change
much over time. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">test "layout links" do
  get root_path
  assert_template 'static_pages/home'
  assert_select "a[href=?]", root_path, count: 2
  assert_select "a[href=?]", help_path
  assert_select "a[href=?]", about_path
  assert_select "a[href=?]", contact_path
end
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Code</th>
<th scope="col" class="left">Matching HTML</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">assert<sub>select</sub> "div"</td>
<td class="left">&lt;div&gt;foobar&lt;/div&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "div", "foobar"</td>
<td class="left">&lt;div&gt;foobar&lt;/div&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "div.nav"</td>
<td class="left">&lt;div class="nav"&gt;foobar&lt;/div&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "div#profile"</td>
<td class="left">&lt;div id="profile"&gt;foobar&lt;/div&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "div[name=yo]"</td>
<td class="left">&lt;div name="yo"&gt;hey&lt;/div&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "a[href=?]", '/', count: 1</td>
<td class="left">&lt;a href="/"&gt;foo&lt;/a&gt;</td>
</tr>

<tr>
<td class="left">assert<sub>select</sub> "a[href=?]", '/', text: "foo"</td>
<td class="left">&lt;a href="/"&gt;foo&lt;/a&gt;</td>
</tr>
</tbody>
</table>


<p>
<b>User signup: a first step</b>. <br  />
We will make a route for the singup page and create a second
controller. There are three steps for representing users on the sample
app site:
</p>
<ol class="org-ol">
<li>layout and routing of the signup page (here)
</li>
<li>modeling users (ch6)
</li>
<li>user registration and account activation (ch7)
</li>
</ol>

<p>
User controller. <br  />
</p>
<pre class="example">
$ rails generate controller Users new
</pre>
<p>
We <code>generate</code> the simplest controller that meets our needs, viz one
with a stub signup page for new users. Following REST, we'll call the
action for new users <code>new</code>. <br  />
The result creates a Users controller with a <code>new</code> action, a stub for
a user view, a minimal test for the new user page, and the routing. 
</p>

<p>
On multiple assertions in single test. <br  />
Some developers insist that a single test shouldn’t contain multiple
assertions. I find this practice to be unnecessarily complicated,
while also incurring an extra overhead if there are common setup tasks
needed before each test. In addition, a well-written test tells a
coherent story, and breaking it up into individual pieces disrupts the
narrative. I thus have a strong preference for including multiple
assertions in a test, relying on Ruby (via minitest) to tell me the
exact lines of any failed assertions. 
</p>

<p>
What we learned in this chapter
</p>
<ul class="org-ul">
<li>Using HTML5, we can define a site layout with logo, header, footer, and main body content.
</li>
<li>Rails partials are used to place markup in a separate file for convenience.
</li>
<li>CSS allows us to style the site layout based on CSS classes and ids.
</li>
<li>The Bootstrap framework makes it easy to make a nicely designed site quickly.
</li>
<li>Sass and the asset pipeline allow us to eliminate duplication in our CSS while packaging up the results efficiently for production.
</li>
<li>Rails allows us to define custom routing rules, thereby providing named routes.
</li>
<li>Integration tests effectively simulate a browser clicking from page to page. 
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Modeling users</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li>we create a <i>data model</i> for users of our site, together with a way
to store that data
</li>
<li>ch7- give users the ability to sign up for our site and create a
user and profile page
</li>
<li>ch8 and ch9- let them log in and log out as well
</li>
<li>ch10- protect pages from improper access
</li>
<li>ch11 and ch12- add account activations (thereby confirming valid
email) and password resets
</li>
</ul>

<p>
Rolling our own authentication system. <br  />
Virtually all web apps require a login and authentication system of
some sort. Most web frameworks (Rails included) have a plethora of
authentication and authorization systems (Clearance, Authlogic,
Device, CanCan and non-Rails-specific solutions built on OpenID or
OAuth). Why reinvent the wheel? <br  />
Authentication on most sites requires extensive
customization. Mofifying a third-party product is often more work than
writing the system from scratch. Also, off-the-shelf systems can be
"black boxes". Writing our own helps us understand (and provides the
ability to modify) the internals of others.
</p>

<p>
<b>User model</b>. <br  />
Although ultimate goal is to create a signup page for our site. Before
we accept information from users, we must create data structures to
capture and store it. <br  />
We are dealing with the M in MVC. The default Rails solution the
problem of persistence is to use a <i>database</i> for long-term data
storage. The default library for interacting with the database is
<i>Active Record</i>. Active Record comes with a host of methods for
creating, saving, and finding data objects, all without having to use
the structured query language SQL. <br  />
Moreover, Rails has a feature called <i>migrations</i> to allow data
definitions to be written in pure Ruby, without having to learn an SQL
DDL. In effect, Rails insulates you almost entirely from the details
of the database.
</p>

<p>
Database migrations. <br  />
Recall: we created a custom-built <code>User</code> class and created user
objects through the Rails console. That class served as a useful
example, but lacked the critical property of <i>persistence</i>: when we
created a User object it disappeared as soon as we exited the Rails
console. Our goal is to create a model to persist users data. <br  />
When using Rails to model users we don't need to identify the
attributes explicitly (Rails uses a RDB by default). 
</p>
<pre class="example">
We generated a Users controller with:
$ rails generate controller Users new
To generate a model, we use the analogous command
$ rails generate model User name:string email:string
</pre>
<p>
Note. In contrast to the plural convention for controller names,
models names are singular: a Users controller, but a User model. <br  />
The result of the model generator is a migration file. Migrations
provide a means to alter the structure of the RDB incrementally. <br  />
The migration consists of a <code>change</code> method that determines the change
to be made to the database. The <code>create_table</code> method accepts a block
with one block variable, in this case called <code>t</code> for table. Inside the
block, the <code>create_table</code> method uses the <code>t</code> object to create <code>name</code>
and <code>email</code> columns in the database, both of type string. Here the
table name is plural, <code>users</code>, even though the model name is singular
<code>User</code>, reflecting the linguistic convention followed by Rails: 
</p>
<ul class="org-ul">
<li>a model represents a single user
</li>
<li>a database table consists of many users.
</li>
</ul>
<p>
<code>t.timestamps</code> creates two colums, <code>created_at</code> and <code>updated_at</code>,
which are timestamps for the record. <br  />
We run <code>rails db:migrate</code> to 'migrate up'. The first time its run, it
creates a file <code>db/development.sqlite3</code>, which is an SQLite
database. <br  />
Under the hood, this command executes the <code>drop_table</code> command to remove
the users table from the database. The reason this works is that the
change method knows that <code>drop_table</code> is the inverse of <code>create_table</code>,
which means that the rollback migration can be easily inferred. In the
case of an irreversible migration, such as one to remove a database
column, it is necessary to define separate up and down methods in
place of the single change method. Read about migrations in the Rails
Guides for more information.
</p>
<div class="org-src-container">

<pre class="src src-ruby">def change
    create_table :users do |t|
      t.string :name
      t.string :email

      t.timestamps
    end
</pre>
</div>


<p>
Creating user objects. <br  />
<code>rails console --sandbox</code> for when we don't want to make any
changes. An class inheriting from Active Record also takes an
initialization hash to set the object attributes:
</p>
<pre class="example">
&gt;&gt; user = User.new(name: "Lupo Zen", email: "lzen@example.com")
=&gt; #&lt;User id: nil, name: "Lupo Zen", email: "lzen@example.com", 
</pre>
<p>
created<sub>at</sub>: nil, updated<sub>at</sub>: nil&gt;
</p>
<pre class="example">
&gt;&gt; user.valid?
true
</pre>
<p>
Our <code>user</code> object is valid, as verified by calling the <code>valid?</code>
method (cf. below). So far we've only created the object in memory
(note the <code>id</code> column). We can use the <code>save</code> method to persist
objects from memory to the database. You can learn a lot by reading
by reading the SQL corresponding to Active Record commands. <br  />
The <code>create</code> method combins the <code>new</code> and <code>save</code> method to directly
persist. While <code>save</code> returns a boolean to determine if the user was
saved, <code>create</code> simply returns the user object back. The inverse is
the <code>destroy</code> method which also returns the object in question. The
destroyed object still exists in memory. <br  />
So how do we know if we really destroyed an object? And for saved and
non-destroyed objects, how can we retrieve users from the database? We
need to learn how to use Active Record to find user objects. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&gt;&gt; user.save
(0.4ms)  SAVEPOINT active_record_1
  SQL (0.8ms)  INSERT INTO "users" 
  ("name", "email", "created_at", "updated_at") 
  VALUES ($1, $2, $3, $4) RETURNING "id"  
  [["name", "Lupo Zen"], ["email", "lzen@example.com"], 
  ["created_at", 2016-08-19 23:43:33 UTC], 
  ["updated_at", 2016-08-19 23:43:33 UTC]]
   (0.3ms)  RELEASE SAVEPOINT active_record_1
=&gt; true
&gt;&gt; user
=&gt; #&lt;User id: 1, name: "Lupo Zen", email: "lzen@example.com", 
  created_at: "2016-08-19 23:43:33", updated_at: "2016-08-19 23:43:33"&gt;
</pre>
</div>

<p>
Finding user objects. <br  />
</p>
<ul class="org-ul">
<li><code>User.find(1)</code>: matches the id field of user records. 
</li>
<li><code>User.find_by(email: "...")</code>: match specified column with
specified paramter of a user record.
</li>
<li><code>User.first</code> : first user of the database.
</li>
<li><code>User.all</code> : returns all the users in the database as an object of
class <code>ActiveRecord::Relation</code> (effectively an array).
</li>
<li><code>user.reload</code> : reloads that in memory <code>user</code> object from the
database copy. We can change the in memory copy and persist with
<code>save</code>. In effect, reassigning is a way to update multiple attributes.
</li>
<li><code>user.update_attributes(name: "...")</code> a second way to update
multiple attributes. Returns boolean as sentinel value.
</li>
</ul>

<p>
Updating user objects. <br  />
Once we've create objects, we often want to update them. There are two
basic ways to do this.
</p>
<ul class="org-ul">
<li><code>save</code>: we can assign attributes individually, then <code>save</code>, then
<code>reload</code> from the database to see the affected attributes (as well
as the <code>user.updated_at</code> attribute).
</li>
<li><code>update_attributes</code>: the method accepts a hash of attributes, and on
success performs both the update and save in one step (returning
<code>true</code> to indicate that the save went through). Note- If any of the
validation fails, such as when a password is required to save a
record, the call to <code>update_attributes</code> will fail. We use the
singular to bypass this restriction.
</li>
</ul>
<div class="org-src-container">

<pre class="src src-ruby">assignment then save
&gt;&gt; user           # Just a reminder about our user's attributes
=&gt; #&lt;User id: 1, name: "Michael Hartl", email: "mhartl@example.com",
created_at: "2016-05-23 19:05:58", updated_at: "2016-05-23 19:05:58"&gt;
&gt;&gt; user.email = "mhartl@example.net"
=&gt; "mhartl@example.net"
&gt;&gt; user.save
=&gt; true
reload from the database
&gt;&gt; user.email
=&gt; "mhartl@example.net"
&gt;&gt; user.email = "foo@bar.com"
=&gt; "foo@bar.com"
&gt;&gt; user.reload.email
=&gt; "mhartl@example.net

update attribute method call
&gt;&gt; user.update_attribute(:name, "El Duderino")
=&gt; true
&gt;&gt; user.name
=&gt; "El Duderino"
</pre>
</div>

<p>
<b>User validations</b>. <br  />
The User model now has working <code>name</code> and <code>email</code> attributes, but they
are completely generic; any string will do. We will add validations
for <code>name</code> not to be blank, <code>email</code> should match the specific format
characteristic of email addresses. Moreover, since we'll be using
email addresses as unique usernames when users log in, we shouldn't
allow email duplicates in the database. <br  />
Active Record allows us to impose contraints on fields values using
<i>validations</i>. We cover the most common cases, validating <i>presence</i>,
<i>length</i>, <i>format</i> and <i>uniqueness</i>. Later we cover <i>confirmation</i>. In
ch7 we'll see how validations give us convenient error messages when
users make submissions that violate them. 
</p>

<p>
A validity test. <br  />
Model validation is a perfect fit for TDD. It's difficult to be
confident that a given validation is doing exactly what we expec it to
without writing a failing test and then getting it to pass. <br  />
Our method:
</p>
<ul class="org-ul">
<li>start with a <i>valid</i> model object,
</li>
<li>set one of its attributes to something we want to be invalid,
</li>
<li>and test that it in fact is invalid.
</li>
</ul>
<p>
As a safety net, we'll first write a test to make sure the initial
model object is valid. This way, when the validation tests fail we'll
know it's for the right reason (and not bc the initial object was
invalid in the first place). <br  />
To write a test for a valid object, we'll create an initially valid
User model object <code>@user</code> using the special <code>setup</code> method which
automatically gets run before each test. Bc <code>@user</code> is an instance
variable, it's automatically available in all the tests, and we can
test its validity using the <code>valid?</code> method. The <code>assert</code> method
succeeds if <code>@user.valid?</code> returns <code>true</code> and fails on <code>false</code>. <br  />
Since the <code>User</code> class has no <code>validates</code> methods, the model is
valid. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">def setup
  @user = User.new(...)
end
test "should be valid" do
  assert @user.valid?
end
</pre>
</div>

<p>
Validity presence. <br  />
<i>Presence</i> simply verifies that a given attribute is present. We start
with a test for the presence of a <code>name</code> attribute:
</p>
<ul class="org-ul">
<li>set the <code>@user</code> variable's <code>name</code> to a blank string
</li>
<li>check (via <code>assert_not</code>) that the resulting User object is not
valid.
<pre class="example">
test "name should be present" do
  @user.name = "     "
  assert_not @user.valid?
end
</pre>
</li>
</ul>
<p>
Running <code>$ rails test:models</code> yields RED (failing). This is the
behavior we expect our model to follow, given a blank name, the
statement "assert that the model is not valid" should be true. We
augment the model object to make the statement true:
</p>
<pre class="example">
class User &lt; ApplicationRecord
  validates :name, presence: true
end
</pre>
<p>
Not only do the tests yield GREEN (pass), but we can also see this in
action using <code>$ rails console --sandbox</code>. Trying to save a model with
a blank no longer shows the SQL query, rather it displays a red
<code>ROLLBACK TO SAVEPOINT</code>. <br  />
<code>errors</code> displays the address of any associated errors with the
model. <code>errors.full_messages</code> displays the errors array with the
values of the errors. 
</p>

<p>
Same process should be followed for validating the presence of the
email attribute of the User model:
</p>
<ul class="org-ul">
<li>write test statement for expected behavior (via <code>assert_not</code>) in the
<code>UserTest</code>
<pre class="example">
test "email should be present" do
  @user.email = "     "
  assert_not @user.valid?
end
</pre>
</li>
<li>run the test, see it fail (RED): <code>$ rails test:models</code>
</li>
<li>augment the model with intentions of providing expected behavior:
<code>validates :email, presence: true</code>
</li>
<li>run the test, see it pass (GREEN): <code>$ rails test:models</code>
</li>
</ul>

<p>
Length validation. <br  />
The user’s names will be displayed on the sample site, so we should
enforce some limit on their length.
</p>
<pre class="example">
test "name should not be long" do
  @user.name = "a" * 51  # over 50 is considered long
  assert_not @user.valid?
end
</pre>
<p>
This test fails since the user has no length validation. We add length
validation to the user model:
</p>
<pre class="example">
validates :name, presence: true, length: { maximum: 50 }
</pre>
<p>
<code>$ rails test:models</code> yields GREEN. 
</p>

<p>
Format validation. <br  />
The <code>email</code> attribute must satisfy more stringent requirements of
being a valid email address. So far, we've only reject blank email
addresses. Here, we require the email to conform to the familiar
pattern <code>user@example.com</code>. <br  />
Neither the test nor the validation will be exhaustive, just good
enough to accept most email addresses and reject most invaild
ones. Recall: the tests specify the behavior we expect. So the test
with the valid addresses are examples of what we expect to be valid
emails. The tests with invalid email address are examples of what we
expect to be invalid. We augment the model with the email validation
code that makes both these examples pass. In a way, we are defining
the boundary conditions of the correct and incorrect behavior of the
model, then implementing the least amount of functionality to make
these assertions examples pass.  <br  />
Bc email format validation is tricky and error-prone, we'll start with
passing tests for <i>valid</i> email addresses to catch any errors in the
validation. <br  />
Remark: we can create an array of strings using the <code>%w[...]</code>
construct.Below we use <code>assert</code> with the second, optional, parameter as our
custom message. Recall: the interpolated <code>inspect</code> method returns the
value of the objects <code>to_s</code> method.
</p>
<div class="org-src-container">

<pre class="src src-ruby">test "email validation should accept valid addresses" do
  valid_addresses = %w[user@example.com USER@foo.COM A_US-ER@foo.bar.org
                       first.last@foo.jp alice+bob@baz.cn]
  valid_addresses.each do |valid_address|
    @user.email = valid_address
    assert @user.valid?, "#{valid_address.inspect} should be valid"
  end
end
test "email validation should not accept invalid addresses" do
  invalid_addresses = %w[user@example,com user_at_foo.org 
              user.name@example. foo@bar_baz.com foo@bar+baz.com ]
  invalid_addresses.each do |invalid_address|
    @user.email = invalid_address
    assert_not @user.valid? , "#{invalid_address.inspect} should be invalid"
  end
end
</pre>
</div>
<p>
The application code for the email format validation uses the <code>format</code>
validation, which works like this: <code>validates :email, format: { with:
/&lt;regexp&gt;/ }</code>. Regular expressions are uses for matching patterns in
strings. Here, we use it to match valid email addresses while not
matching invalid ones. There exists a <a href="http://emailregex.com">full regex</a> for matching email
addresses according to the <a href="http://www.ietf.org/rfc/rfc5322.txt">official email standard</a>, but it's enormous,
obscure, and possibly counter-productive. We'll adopt a pragmatic
regex that has proven to be robust in practice (see <a href="http://www.rubular.com/r/aE4zppL0TA">rublar</a> leave off
the \A and \z characters so that you can match more than one email
address at a time in the given test string) : 
</p>
<pre class="example">
VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Expression</td>
<td class="left">Meaning</td>
</tr>

<tr>
<td class="left">/\A[\w+\-.]+@[a-z\d&#x00ad;.]+\.[a-z]+\z/i</td>
<td class="left">full regex</td>
</tr>

<tr>
<td class="left">\A</td>
<td class="left">match start of a string</td>
</tr>

<tr>
<td class="left">[\w+&#x00ad;.]+</td>
<td class="left">at least one word character, plus, hyphen, or dot</td>
</tr>

<tr>
<td class="left">@</td>
<td class="left">literal “at sign”</td>
</tr>

<tr>
<td class="left">[a-z\d&#x00ad;.]+</td>
<td class="left">at least one letter, digit, hyphen, or dot</td>
</tr>

<tr>
<td class="left">\.</td>
<td class="left">literal dot</td>
</tr>

<tr>
<td class="left">[a-z]+</td>
<td class="left">at least one letter</td>
</tr>

<tr>
<td class="left">\z</td>
<td class="left">match end of a string</td>
</tr>

<tr>
<td class="left">i</td>
<td class="left">case-insensitive</td>
</tr>
</tbody>
</table>
<p>
Applying the regex to the <code>email</code> format validation yields:
</p>
<pre class="example">
validates :email, presence: true, length: { maximum: 255 }, 
                  format: { with: VALID_EMAIL_REGEX }
</pre>
<p>
The regex <code>VALID_EMAIL_REGEX</code> is a <i>constant</i>, idicated in Ruby by a
name starting with a capital letter. 
Note: the regex above allows multiple dots like <code>foo@bar..com</code>. The
following is a fix: <code>VALID_EMAIL_REGEX =
/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i</code>. 
</p>

<p>
Uniqueness validation. <br  />
To enforce uniqueness of email addresses (so that we can use them as
usernames), we'll be using the <code>:unique</code> option in the <code>validates</code>
method. We start with some tests. We cannot use <code>User.new</code> as before,
this behavior requires persisting to the database to ensure uniquess
at the persistence level. <br  />
We specify that the behavior of saving two users with the same email
should not be valid (via the <code>dup</code> method). 
</p>
<div class="org-src-container">

<pre class="src src-ruby">test "email addresses should be unique" do
  duplicate_user = @user.dup
  @user.save
  assert_not duplicate_user.valid?
end
</pre>
</div>
<p>
Adding <code>uniqueness: true</code> to the User email <code>validates</code> method yields
the desired GREEN. <br  />
Email addresses are typically processed as if they were
case-insensitive&#x2013;i.e,=foo@bar.com= is the same as <code>FOO@BAR.COM</code> or
<code>FoO@BAr.coM</code>&#x2013; so our validation should incorporate this as
well. Adding the following line to our email unique example test
yields a failing test:
</p>
<pre class="example">
duplicate_user.email = @user.email.upcase
</pre>
<p>
If this test feels a little abstract, go ahead and fire up the
console:
</p>
<div class="org-src-container">

<pre class="src src-ruby">$ rails console --sandbox
&gt;&gt; user = User.create(name: "Example User", email: "user@example.com")
&gt;&gt; user.email.upcase
=&gt; "USER@EXAMPLE.COM"
&gt;&gt; duplicate_user = user.dup
&gt;&gt; duplicate_user.email = user.email.upcase
&gt;&gt; duplicate_user.valid?
=&gt; true
</pre>
</div>
<p>
Hence the test is RED. <code>uniqueness</code> accepts an option:
<code>case_sensitive: false</code>. This yields the desired GREEN. 
Problem: Active Record uniqueness validation does not guarantee
uniqueness at the database level. 
Consider the scenario:
</p>
<ol class="org-ol">
<li>Alice uses <code>alice@wonderland.com</code>
</li>
<li>Alice clicks 'Submit' twice, sending two quick requests
</li>
<li>Requests pass validation in memory, so both are persisted:
<ol class="org-ol">
<li>Request 1 creates a user in memory that passes validation
</li>
<li>Request 2 does the same and also pases validation
</li>
<li>Request 1's user gets saved
</li>
<li>Request 2's user gets saved
</li>
</ol>
</li>
<li>Result: two user records with the same email despite the uniqueness
validation
</li>
</ol>
<p>
Solution: enforce uniqueness at the database level as well as the
model level. Our method: create a database <i>index</i> on the email column
and require that index to be unique. <br  />
Dealing with the database level requires migrations:
</p>
<pre class="example">
$ rails generate migration add_index_to_users_email
</pre>
<p>
Unlike the users migration, the
<code>[timestamp]_add_index_to_users_email.rb</code> migration is not
pre-defined, so we fill in its contents: 
</p>
<pre class="example">
class AddIndexToUsersEmail &lt; ActiveRecord::Migration[5.0]
  def change
    add_index :users, :email, unique: true
  end
end
</pre>
<p>
We migrate the database <code>$ rails db:migrate</code>. (If this fails, try
exiting any running sandbox console sessions, which can lock the
database and prevent migrations.)
Remark: an alternative to generating a new migration is to add these
changes to the <code>users</code> <code>change</code> method. This requires rolling back
then migrating up. <br  />
Note. The Rails Way is to use migrations every time we discover that
our data model needs to change. <br  />
#+TODO implement this scenrio when learning ruby threads
Already attempted this using Ruby multi-assignement
</p>
<div class="org-src-container">

<pre class="src src-ruby"> alice = User.new(name: "Alice", email: "alice@wonderland.com")
 =&gt; #&lt;User id: nil, name: "Alice", email: "alice@wonderland.com", 
    created_at: nil, updated_at: nil&gt; 
2.3.1 :009 &gt; alice2 = alice.dup
 =&gt; #&lt;User id: nil, name: "Alice", email: "alice@wonderland.com", 
    created_at: nil, updated_at: nil&gt; 
2.3.1 :010 &gt; r1, r2 = alice.save, alice2.save
   (0.2ms)  SAVEPOINT active_record_1
  User Exists (0.4ms)  SELECT  1 AS one FROM "users" 
    WHERE "users"."email" = $1 LIMIT $2  [["email", "alice@wonderland.com"],
     ["LIMIT", 1]]
  SQL (0.3ms)  INSERT INTO "users" ("name", "email", 
    "created_at", "updated_at") VALUES ($1, $2, $3, $4) 
    RETURNING "id"  [["name", "Alice"], ["email", "alice@wonderland.com"], 
    ["created_at", 2016-08-21 21:17:13 UTC], 
    ["updated_at", 2016-08-21 21:17:13 UTC]]
   (0.1ms)  RELEASE SAVEPOINT active_record_1
   (0.1ms)  SAVEPOINT active_record_1
  User Exists (0.2ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" =
     $1 LIMIT $2  [["email", "alice@wonderland.com"], ["LIMIT", 1]]
   (0.1ms)  ROLLBACK TO SAVEPOINT active_record_1
 =&gt; [true, false] 
2.3.1 :011 &gt; r1, r2 = alice.valid?, alice2.valid?
  User Exists (0.6ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" =
     $1 AND ("users"."id" != $2) LIMIT $3  [["email", "alice@wonderland.com"], 
    ["id", 2], ["LIMIT", 1]]
  User Exists (0.3ms)  SELECT  1 AS one FROM "users" WHERE "users"."email" = 
    $1 LIMIT $2  [["email", "alice@wonderland.com"], ["LIMIT", 1]]
 =&gt; [true, false]
</pre>
</div>


<p>
Database indices. <br  />
When creating a column in a database, it's important to consider if we
need to <i>find</i> records by that column. For example, when we allow
users to log in the sample app, we need to find the corresponding user
to the submitted email address. With the current data model, we must
do a linear search (key being the email requested) through all the
users of the database&#x2013; i.e a <i>full-table</i> scan. 
Providing an inedex on the email column fixes the problem.
</p>

<p>
After migrating. The test suite is RED due to violation of the
uniqueness constraint in the <i>fixtures</i>, which contain sample data for
the test database. Fixture data doesn't run through validations so
they did not fail earlier tests. They are persisted in the test
database and bc they have the same email, all tests fail. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">one:
  name: MyString
  email: MyString

two:
  name: MyString
  email: MyString
</pre>
</div>
<p>
Simply removing the contents of the file passes the tests. 
</p>

<p>
Some databases use case-sensitive indices, but our app treats them the
same. To avoid this incompatibility, we'll standardize on all
lower-case addresses using a <code>before_save</code> callback in the <code>User</code> model. 
</p>
<pre class="example">
before_save { self.email = email.downcase }
</pre>
<p>
At this point, the Alice scenario above will work fine. 
</p>

<p>
<b>Adding a secure password</b>. <br  />
Method: require each user to have a password (w/ password
confirmation), then store a <i>hashed</i> version in the database. We add a
way to <i>authenticate</i> a user based on a given password (cf. ch8) to
allow users to log in to the site.  Here a <i>hash</i> refers to the result
of applying an irreversible hash function to input data. <br  />
Authenticating users :
</p>
<ol class="org-ol">
<li>take a submitted password
</li>
<li>hash it
</li>
<li>compare the result to the hashed value stored in the database
</li>
<li>if the two match, then submitted password is correct (user authenticated)
</li>
</ol>
<p>
By comparing hashed values instead of raw passwords, we will be able to
authenticate users without storing the raw passwords themeselves. Even
if our database is compromised, our users' passwords will still be
secure.
</p>

<p>
A hashed password. <br  />
Most of the secure password machinery will be implemented using a
single Rails method <code>has_secure_password</code>. When included, it adds:
</p>
<ul class="org-ul">
<li>ability to save securely hashed <code>password_digest</code> attribute to db
</li>
<li>pair of virtual attributes (<code>password</code> &amp; <code>password_confirmation</code>)
</li>
<li><code>authenticate</code> method that returns the user when password is correct
</li>
</ul>
<p>
The model must have a <code>password_digest</code> attribute (synonymous with
hashed password). <br  />
To add the <code>password_digest</code> attribute to the <code>User</code> model we must
create a migration: <code>$ rails g migration add_password_digest_to_users
password_digest:string</code>. Then migrate up. <br  />
To make the password digest, <code>has_secure_password</code> uses a bcrypt (via
the bcrypt gem).
</p>

<p>
User has secure password. <br  />
After adding the <code>has_secure_password</code> (see
<a href="http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password">ActiveModel::SecurePassword::ClassMethods)</a> to the User model and
running the tests, we see RED on the tests that assert validity of the
<code>@user</code> from setup. All other tests using <code>assert_not</code> remain passing
since the model remains invalid but now for the wrong reasons (like test
"name should be present"). <code>has_secure_password</code> enforces validation
on the virtual <code>password</code> and <code>password_confirmation</code> attributes, but
the tests create a <code>@user</code> variable w/out these attributes. <br  />
Resulting <code>test/models/user_test.rb</code> is:
</p>
<pre class="example">
def setup   # create a valid user
  @user = User.new(name: "Example User", email: "user@example.com",
                   password: "foobar", password_confirmation: "foobar")
end
</pre>

<p>
Minimum password standards. <br  />
Good practice: enforce minimum standards on passwords (harder to
guess). Password validations: minimum length of 6 and non blank
results in the following added tests. <br  />
Aside: tests are documentation. They should explicitly denote what
functionality they are testing. Consider test "name should not be too
long". The evident assignment of 51 chars is considered to long (as
opposed to 51 literal, different chars) is clear to the reader. The
name itself implies the behavior.
</p>
<pre class="example">
test "name should not be too long" do
  @user.name = "a" *51
  assert_not @user.valid?
</pre>

<p>
Creating and authenticating a user. <br  />
Since users can't sign up through the web (goal in ch7), we use the
<code>create</code> method.
</p>

<p>
<b>Conclusion</b>. <br  />
Starting from scratch, we have a User model w/ name, email, and
password attributes w/ enforcing validations). We have the ability to
securely authenicate users using a given password (all in twelve lines
of code). <br  />
In ch7, we make a working signup form to create new users w/ a page
displaying each users information. 
</p>

<p>
What we learned in this chapter. <br  />
</p>
<ul class="org-ul">
<li>migrations allow us to modify our application's data model
</li>
<li>active record comes w/ a large number of methods for creating and
manipulating data models
</li>
<li>active record validations allow us to place constraints on the data
in our models
</li>
<li>common validations include presence, length, and format
</li>
<li>regular expressions are cryptic but powerful
</li>
<li>defining a database index improves lookup efficiency while allowing
enforcement of uniqueness at the database level
</li>
<li>we can add a secure password to a model using the built-in
<code>has_secure_password</code> method
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Sign up</h2>
<div class="outline-text-2" id="text-7">
<p>
User sign up worflow:
</p>
<ul class="org-ul">
<li>user submits html form with singup information (cf 7.2)
</li>
<li>app creates a new user and saves its attributes to the database
(cf. 7.4)
</li>
<li>the app renders a profile page w/ the newly created user information
</li>
</ul>
<p>
We begin w/ a page <i>showing</i> users (as a first step towards our REST
architecture for users). <br  />
We rely on the User model validations to increase the odds of new
users having valid emails. In ch11, we'll make sure of email validity
by adding a separate account activation step.
</p>

<p>
<b>Showing users</b>. <br  />
We make a page to display a user's name and profile photo (eventually
we're creating a profile page to show a user's profile image, basic
user data, and a list of microposts). 
</p>

<p>
Debug and Rails environments. <br  />
The profiles will be the first true piece of dynamic pages (i.e., the
view will be a singe page of code, but each profile will be customized
using information retrieved from the application's database). <br  />
We add debug information to our site layout by displaying useful
information using the <code>debug</code> method and <code>param</code> variable in
<code>app/views/layouts/application.html.erb</code>:
</p>
<pre class="example">
&lt;%= debug(params) if Rails.env.development? %&gt;
</pre>

<p>
Rails environments. <br  />
Rails comes equipped w/ three environments: <code>test</code>, <code>development</code>, and
<code>production</code>. The default environment for the Rails console is
<code>development</code>. In the Rails console, <code>Rails.env</code> notifies us of the
current environment. To run a console in a different environment (to
debug a test, for instance), you can pass the environment as a
parameter: <code>$ rails console test</code>. You can also run different
environments: <code>$ rails server --environment production</code> to view your
app running in production. <br  />
To view the app running in production, we need a production database
(created by running <code>rails db:migrate</code> in production):
</p>
<pre class="example">
$ rails db:migrate RAILS_ENV=production
</pre>

<p>
A users resource. <br  />
To make a user profile page, we need a user in the database: how can
the site have a user before there is a working signup page? We follow
the conventions of the REST architecture, which means representing
data as <i>resources</i> that can be created, shown, updated, or
destroyed&#x2013;four actions corresponding to the four fundamental
operations <code>POST</code>, <code>GET</code>, <code>PATCH</code>, and <code>DELETE</code> defined by the HTTP
standard. <br  />
When following the REST principles, resources are typically referenced
using the resource name and a unique identifier. In the context of
users&#x2013;which we're now thinking of as a Users resource&#x2013;we should view
the user with id 1 by issuing a <code>GET</code> request to the URL/users/1. Here
the <code>show</code> action is implicit in the type of request&#x2013;when Rails' REST
features are activated, <code>GET</code> requests are automatically handled by
the <code>show</code> action. <br  />
Although we have the Users model already created, we get an
<code>ActionController::RoutingError</code> when the browser issues a <code>GET
/users/1</code> request. By adding <code>resources :users</code> to our
<code>config/routes.rb</code> file we now have all the REST routes for the user
resource (see <code>rails routes</code> command). <br  />
Now that we have the REST routing for the users resource (i.e.,
<code>POST</code>, <code>GET</code>, <code>PATCH</code>, and <code>DELETE</code> corresponding to the actions
create, show, update, and destroy), we still get an error when
requesting <code>GET /users/1</code> (returns an <code>Unknown action</code> error). <br  />
We begin with a minimalistic profile by displaying the name and email
inside the show template in the users views. Again, requesting results
in an <code>undefined method 'name' for nil:NilClass</code> error since we don't
have a <code>@user</code> instance variable inside the <code>show</code> controller. Inside
the <code>users_controller.rb</code>, we have:
</p>
<pre class="example">
def show 
  @user = User.find(params[:id])
end
</pre>
<p>
We use the <code>params</code> to retrieve the user id. When we make the
appropriate request to the Users controller, <code>params[:id]</code> will be the
user id specified in the URL (in this case <code>1</code>). The effect is
equivalent to <code>User.find(1)</code> (technically <code>params[:id]</code> is a string,
but Rails converts it to an integer before passing it to
<code>User.find</code>). 
</p>

<p>
Debugger. <br  />
Aside from using the <code>debug</code> method, we can use the <code>byebug</code> gem by
simply adding the line <code>debugger</code> to controllers we want to debug.
</p>
<ol class="org-ol">
<li>add <code>beybug</code> to <code>Gemfile</code>, then executed <code>$ bundle install</code>
</li>
<li>add the text <code>debugger</code> in the controller actions to debug
</li>
<li>when visiting that route &amp; action, we can see the <code>(byebug)...</code> output
inside the Gemfile
</li>
<li>to release the prompt and continue execution of the application,
press Ctrl-D, then remove the <code>dubugger</code> line from the action
</li>
</ol>
<p>
Whenever confused about something in a Rails app, it's good practice
to put <code>debugger</code> close to the code you think might be causing the
trouble. Inspecting the state of <code>byebug</code> is a powerful method for
tracking down applications errors and interactively debugging your
application. 
</p>

<p>
A Gravatar image and a sidebar. <br  />
Rather than managing image uploads, cropping, and storage, we use
Gravatar (a free service that allows users to upload and associate
images with their email addresses). We delegate image handling to ch13
(which follows the enough to be dangerous motto). We define a
<code>gravatar_for</code> helper function to return a Gravatar image for a given
user. We want to put the following in the show users view:
</p>
<pre class="example">
&lt;%= gravatar_for @user %&gt;
</pre>
<p>
Recall: methods defined in any helper file are available in any view,
but we put the <code>gravatar_for</code> method in the file for helpers
associated with the Users controller (which makes sense
logically). Gravatar URLs are based on an MD5 hash of the user's email
address, so we need to convert our email using the <code>Digest</code> library:
</p>
<pre class="example">
Digest::MD5::hexdigest(email.downcase)
</pre>
<p>
The resulting helper <code>UsersHelper</code> function follows:
</p>
<div class="org-src-container">

<pre class="src src-ruby"># Returns the Gravatar for the given user.
def gravatar_for(user)
  gravatar_id = Digest::MD5::hexdigest(user.email.downcase)
  gravatar_url = "https://secure.gravatar.com/avatar/#{gravatar_id}"
  image_tag(gravatar_url, alt: user.name, class: "gravatar")
end
</pre>
</div>
<p>
We add a user sidebar using the <code>aside</code> tag with bootstrap styling
(viz. <code>row</code> and <code>col-md-4</code> classes). With the html elements and css
classes in place, we can style the profile page w/ scss inside the
<code>app/assets/stylesheets/custom.scss</code>. 
</p>

<p>
<b>Singup form</b>. <br  />
</p>

<p>
Using <code>form_for</code>. <br  />
The <code>form_for</code> helper method takes in an active record  object and
builds a form using the object's attributes. Since <code>/signup</code> is routed
to the <code>new</code> action in the Users controller, we first create the User
object required as an argument to <code>form_for</code>:
</p>
<div class="org-src-container">

<pre class="src src-ruby">.../users_controller.rb
  def new
    @user = User.new
  end

.../new.html.erb
  &lt;div class="col-md-6 col-md-offset-3"&gt;
    &lt;%= form_for(@user) do |f| %&gt;
    &lt;%= f.label :name %&gt;
    &lt;%= f.text_field :name %&gt;
    &lt;%= f.label :email %&gt;
    &lt;%= f.text_field :email %&gt;
    &lt;%= f.label :password %&gt;
    &lt;%= f.text_field :password %&gt;
    &lt;%= f.label :password_confirmation %&gt;
    &lt;%= f.text_field :password_confirmation %&gt;
    &lt;%= f.submit "Create my account", class: "btn btn-primary" %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
</pre>
</div>

<p>
Signup form. <br  />
</p>
<pre class="example">
&lt;%= form_for(@user) do |f| %&gt;
...
&lt;% end %&gt;
</pre>
<p>
The <code>form_for</code> take a block w/ one variable (viz. <code>|f|</code> for
"form"). When the <code>f</code> object is called w/ a method corresponding to an
html form element, <code>f</code> returns code for that element specifically
design to set an attribute of the <code>@user</code> object.
So <code>f.label</code> &amp; <code>f.text_field</code> create the html needed to make a labeled
text field element appropriate for setting the <code>name</code> attribute of a
User model. The generated html attribute types <code>text</code> &amp; <code>email</code> simply
display their contents, whereas type <code>password</code> obscures the input for
security reasons. Actually type <code>email</code> will cause mobile devices to
display a special keyboard optimized for entering email addresses. <br  />
As we see, the key to creating a yser us the special <code>name</code> attribute
in each <code>input</code>. They allow Rails to construct an initialization hash
(via the <code>params</code> variable) for creating users using the form
values. <br  />
Rails creates the <code>form</code> tag using the <code>@user</code> object: bc every Ruby
object knows its own class (Rails figures out that <code>@user</code> is of class
<code>User</code>). Moreover, since <code>@user</code> is a <i>new</i> user (by the <code>new</code> method
call), Rails knows to construct a form w/ the <code>post</code> method. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">&lt;%= f.label :name %&gt;
&lt;%= f.text_field %&gt;
# produces the HTML
&lt;label for="user_name"&gt;Name&lt;/label&gt;
&lt;input id="user_name" name="user[name]" type="text" /&gt;

&lt;%= f.label :email %&gt;
&lt;%= f.email_field :email %&gt;
# produces the HTML 
&lt;label for="user_email"&gt;Email&lt;/label&gt;
&lt;input id="user_email" name="user[email]" type="email" /&gt;

&lt;%= f.label :password %&gt;
&lt;%= f.password_field :password %&gt;
# produces the HTML
&lt;label for="user_password"&gt;Password&lt;/label&gt;
&lt;input id="user_password" name="user[password]" type="password" /&gt;

&lt;input name="utf8" type="hidden" value="&amp;#x2713;" /&gt;
&lt;input name="authenticity_token" type="hidden"
       value="NNb6+J/j46LcrgYUC60wQ2titMuJQ5lLqyAbnbAUkdo=" /&gt;
</pre>
</div>
<p>
This code, which isn’t displayed in the browser, is used internally by
Rails, so it’s not important for us to understand what it
does. Briefly, it uses the Unicode character &amp;#x2713; (a checkmark ✓)
to force browsers to submit data using the right character encoding,
and then it includes an authenticity token, which Rails uses to thwart
an attack called a cross-site request forgery (CSRF). Knowing when
it’s OK to ignore details like this is a good mark of technical
sophistication (Box 1.1).).
</p>

<p>
<b>Unsuccessful signups</b>. <br  />
We'll create a signup form that accepts an invalid submission and
re-renders the signup page with a list of errors.
</p>

<p>
A working form. <br  />
Our strategy for the <code>create</code> action is to use the form submission to
make a new user object using the <code>User.new</code> to save that user, and
then render the signup page for possible resubmission. Recall, from
the sign up we have:
</p>
<pre class="example">
&lt;form action="/user" class="new_user" id="new_user" method="post"&gt;
</pre>
<p>
Our first implementation is to pass the generate <code>:user</code> (submitted by
the sign up form) to via the <code>params</code> method to <code>User.new</code> in the
<code>create</code> action. If unsuccessful, i.e. we cannot save the user, the
render the new action:
</p>
<div class="org-src-container">

<pre class="src src-ruby">def create
  @user = User.new(params[:user])  # not the final implementation
  if @user.save
    # Handle a successful save.
  else
    render 'new'
  end
end
</pre>
</div>
<p>
When submitting the form with some invalid signup data, we get an
<code>ActiveModel::ForbiddenAttributesError</code>. The user hash gets passed to
the Users controller as part of <code>params</code>. In the case of posting to
the sign up form, <code>params</code> instead contains a hash of hashes.
</p>
<div class="org-src-container">

<pre class="src src-ruby">"user" =&gt; { "name" =&gt; "Foo Bar",
            "email" =&gt; "foo@invalid",
            "password" =&gt; "[FILTERED]",
            "password_confirmation" =&gt; "[FILTERED]"
          }

# the following two are essentially equivalent
@user = User.new(params[:user])
@user = User.new(name: "Foo Bar", email: "foo@invalid",
                 password: "foo", password_confirmation: "bar")
</pre>
</div>

<p>
Strong parameters. <br  />
Recall: <i>mass assignment</i> involves initializing a Ruby variable using
a hash of values. Initializing the entire <code>params</code> hash is dangerous&#x2013;
it arranges to pass <code>User.new</code> all data submitted by the
user. Suppose, in addition to the current attributes, the User model
included an <code>admin</code> attibute to identify administrative users of the
site. To set such attribute <code>true</code> requires passing the value
</p>
<pre class="example">
admin='1'
</pre>
<p>
as part of <code>param[:user]</code>. Any client can do this via <code>curl</code>, hence
any client has access to administrative priveleges. <br  />
Previous versions of Rails used <code>attr_accessible</code> in the <i>model</i> layer
to solve this problem, but the preferred technique is to use <i>strong
parameters</i> (in the controller layer). Strong parmaters allow the
developer to specify which parameters are <i>required</i> and which ones
are <i>permitted</i>. In addition, passing in a raw <code>params</code> hash as above
will cause an error to be raised, so that Rails applications are now
immune to mass assignment vulnerabilities by default. <br  />
We require the <code>params</code> hash to have a <code>:user</code> attribute, and we want
to permit the name, email, password, and password<sub>confirmation</sub>
attributes (but not others), as follows:
<code>params.require(:user).permit(:name, :email, ...)</code>. The code returns a
version of the <code>params</code> hash with only the permitted attributes (while
raising an error if the <code>:user</code> attributes is missing). <br  />
Since user<sub>params</sub> will only be used internally by the Users controller
and need not be exposed to external users via the web, we’ll make it
private using Ruby’s private keyword.
</p>
<div class="org-src-container">

<pre class="src src-ruby">def create
    @user = User.new(user_params)
    if @user.save
      # Handle a successful save.
    else
      render 'new'
    end
  end

  private

    def user_params
      params.require(:user).permit(:name, :email, :password,
                                   :password_confirmation)
    end
</pre>
</div>

<p>
Signup error messages. <br  />
As a final step in handling failed user creation, we'll add helpful
error messages to indicate the problem that prevented successful
signup. On a failed call of <code>user.save</code>, we can inspect what failed
validation via <code>user.errors.full_messages</code>. To display the messages in
the browser, we'll render an error-messages partial on the user <code>new</code>
page while adding the CSS class <code>form-control</code> to each entry. Note: we
<code>render</code> a partial called ='shared/error<sub>messages'</sub><code>; this reflects a
common Rails convention of using a dedicated =shared/</code> directory for
partials expected to be used in views accross multiple controllers.
</p>

<p>
A test for invalid submission. <br  />
We write tests to automate the testing of forms to verify the correct
behavior upon invalid form submission. First we generate an
integration test file for signing up users, which we'll call
<code>users_signup</code> (adopting the controller convention of plural resource
name):
</p>
<pre class="example">
$ rails generate integration_test users_signup
</pre>
<p>
We verify that clicking the signup button results in <i>not</i> creating a
new user when the submitted information is invalid. We check the
<i>count</i> of users, and under the hood our tests will use the <code>count</code>
method (available on every Active Record class, including <code>User</code>). <br  />
</p>
<div class="org-src-container">

<pre class="src src-ruby">$ rails console
&gt;&gt; User.count
=&gt; 1
</pre>
</div>


<p>
<b>Successful signups</b>
We handle saving anew user (if valid) to the database. 
</p>
<ul class="org-ul">
<li>First, we try to save the user;
</li>
<li>if the save succeeds, the user's information gets written to the
database automatically, and
</li>
<li>we then <i>redirect</i> the browser to show the users profile (w/ a
greeting)
</li>
</ul>

<p>
The finished signup form. <br  />
To complete a working signup form (which freezes on submission), we
need to handle the successful branch of submit. The defualt behavior
for a Rails action is to render the corresponding view, and there
isn't a view template corresponding to <code>create</code>. 
</p>

<p>
The flash. <br  />
We add a message that appears on the subsequent page (welcoming our
new user to our application) and then disappears upon visiting a
second page or on page reload. <br  />
The Rails way to display a temporary message is via a method called
the <i>flash</i>, which we treat like a hash. Rails adopts the convention
of a <code>:success</code> key for a message indicating a successful result. 
</p>

<p>
A test for valid submission. <br  />
</p>

<p>
<b>Professional-grade deployment</b>. <br  />
Now that we have a working signup page, we will make the deployment
professional-grade. We add an important feature to the production app
to make signup secure, and replace the default webserver w/ one
suitable for real-world use. 
</p>

<p>
SSL in production. <br  />
We use Secure Sockets Layer to encrypt all relevant information before
it leaves the users local broser (via the submittion form). We use SSL
site-wide for two reasons: easier implementation and immune to the
critical seesion hijacking vulnerability (cf. 9.1). We enable SSL by
adding  <code>config.force_ssl = true</code> in
<code>config/environments/production.rb</code>. <br  />
Setting up a production site to use SSL requires purchasing and
configuring an SSL certificate for your domain. For applications
running on a Heroku domain, we can piggyback on Heroku's SSL
certificate (automatically enabled). 
</p>

<p>
Production webserver. <br  />
By default, Heroku uses a pure-Ruby webserver called WEBrick, which is
easy to set up and run but isn’t good at handling significant
traffic. As a result, WEBrick isn’t suitable for production use, so
we’ll replace WEBrick with Puma, an HTTP server that is capable of
handling a large number of incoming requests.
</p>

<p>
Conclusion. <br  />
We have laid an essential foundation for all future development. In
ch8 and ch9 we complete our authentication machinery by allowing users
to log in and out of the app (w/ optional 'remember me'
functionality). In ch10, we allow all users to update their account
information, and we allow site administrators to delete users, thereby
completing the full suite of Users resource REST actions from the
users section of <code>$ rails r</code>.
</p>

<p>
What we learned in this chapter:
</p>
<ul class="org-ul">
<li>Rails displays useful debug information via the debug method.
</li>
<li>Sass mixins allow a group of CSS rules to be bundled and reused in
multiple places.
</li>
<li>Rails comes with three standard environments: development, test, and production.
</li>
<li>We can interact with users as a resource through a standard set of REST URLs.
</li>
<li>Gravatars provide a convenient way of displaying images to represent users.
</li>
<li>The form<sub>for</sub> helper is used to generate forms for interacting with
Active Record objects.
</li>
<li>Signup failure renders the new user page and displays error messages
automatically determined by Active Record.
</li>
<li>Rails provides the flash as a standard way to display temporary messages.
</li>
<li>Signup success creates a user in the database and redirects to the
user show page, and displays a welcome message.
</li>
<li>We can use integration tests to verify form submission behavior and
catch regressions.
</li>
<li>We can configure our production application to use SSL for secure
communications and Puma for high performance.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Basic login</h2>
<div class="outline-text-2" id="text-8">
<p>
We’ll implement a basic but still fully functional login system: the
application will maintain the logged-in state until the browser is
closed by the user. The authentication system will be customized based
on login status and identity of the current user. For example, we'll
be able to update the site header w/ login/logout links and a profile
link. <br  />
In ch10, we impose a security model in which:
</p>
<ul class="org-ul">
<li>only logged-in users can visit the user index page,
</li>
<li>only the correct user can access the page for editing thier information,
</li>
<li>and only admin users can delete other users from the database.
</li>
</ul>
<p>
In ch13, we use the identity of a logged-in user to create microposts
associated w/ the user. Ch14 allows the current user to follow other
users of the application (thereby receiving a feed of their
microposts). <br  />
The authentication system from this chapter will serve as a foundation
for the more advanced system of ch9 where, instead of 'forgetting'
users on browser close, we start by <i>automatically</i> remembering users,
and will then optionally remember users based on the value of a
'remember me' checkbox.
</p>

<p>
<b>Sessions</b>. <br  />
HTTP is a stateless protocol. Treating each request as an independent
transaction that is unable to use information from any previous
request. The most common technique for implementing sessions in Rails
involves using cookies, which are small pieces of text placed on the
user's browser. We use the Rails method called <code>session</code> to make
temporary sessions that expire automatically on browser close. In ch9,
we'll learn how to make longer-lived sessions using the closely
related <code>cookies</code> method. <br  />
We model sessions as a RESTful resource:
</p>
<ul class="org-ul">
<li>visiting the login page will render a form for <i>new</i> sessions,
</li>
<li>logging in will <i>create</i> a session,
</li>
<li>and logging out will <i>destroy</i> it.
</li>
</ul>
<p>
The session resource will use cookies (small piece of text placed on
the user's browser), and much of the work involved in login comes from
building this cookie-based authentication machinery. <br  />
We will prepare for constructing a Sessions controller, a login form,
and the relevant controller actions. We'll then complete user login by
adding the necessary session-manipulation code.
</p>

<p>
Sessions controller. <br  />
Logging in and out correspond to particular REST actions of the
Sessions controller:
</p>
<ul class="org-ul">
<li><code>GET new</code>: the login form is handled by the <code>new</code> action
</li>
<li><code>POST create</code>: logging in is handled by sending a POST request to the <code>create</code> action
</li>
<li><code>DELETE destroy</code> logging out is handled by sending a DELETE request to the <code>destroy</code>
  action
</li>
</ul>
<p>
We begin by generating a Sessions controllers w/ a <code>new</code> action:
</p>
<pre class="example">
$ rails generate controller Sessions new
</pre>
<p>
Following the model of the sign up page, our plan is to create a login
form for creating a new sessions. Unlike the Users resource, which
used the special <code>resource</code> method to get the full suite of RESTfull
routes, the Sessions resource will use only named routes, handling
the routes specified above:
</p>
<pre class="example">
./config/routes.rb
get    '/login',    to: 'sessions#new'
post   '/login',    to: 'sessions#create'
delete '/logout',   to: 'sessions#destroy'
</pre>
<p>
Since we've added several custom named routes, it's useful to look at
the complete list of route for our application via <code>$ rails
routes</code>. Viewing the routes in this manner gives us a high-level
overview of the actions supported by our applications.
</p>

<p>
Login form. <br  />
Having defined the relevant controller and route, now we'll fill in
the view for new sessions, i.e., the login form. The login form is
similar in appearance to the signup form, except with two fields
(email and password) in place of four. <br  />
When login information is invalid, we want to re-render the login page
and display an error message. We used error-messages partial to
display error messages, but we saw in that section that those messages
are provided automatically by Active Record. This won't work for
session creation errors bc the session isn't an Active Record object,
so we'll render the error as a flash message instead. <br  />
Recall, the signup form uses the <code>form_for</code> helper, taking as an
argument the user instance variable <code>@user</code> (see signup form). 
<code>form_for(@user)</code> allows Rails to infer that <code>action</code> of the form
should be to <code>POST</code> to the URL <code>/users</code>, in the case of sessions we
need to indicate the <i>name</i> of the resource and the corresponding URL:
</p>
<pre class="example">
for_for(:session, url: login_path)
</pre>
<p>
With the proper <code>form_for</code>, it's easy to make a login form to match
the mockup using the signup form as a model:
</p>
<div class="org-src-container">

<pre class="src src-ruby">&lt;% form_for(:session, url: login_path) do |f| %&gt;
  &lt;%= f.label :email %&gt;
  &lt;%= f.email_field :email, class: 'form-control' %&gt;

  &lt;%= f.label :password %&gt;
  &lt;%= f.password_field :password, class: 'form-control' %&gt;

  &lt;%= f.submit "Log in", class: "btn btn-primary" %&gt;
&lt;% end %&gt;
</pre>
</div>

<p>
Finding and authenticating a user. <br  />
As in the case of creating users (signup), the first step in creating
sessions (login) is to handle <i>valid</i> input. We 
</p>
<ul class="org-ul">
<li>review what happens when a form gets submitted
</li>
<li>then arrange for helpful error messages to appear in the case of login failure
</li>
<li>then lay the foundations for successful login by evaluating each
login submission based on the validity of its email/password
combination
</li>
</ul>
<p>
We start w/ a minimalist <code>create</code> action for the Sessions controller
and add an empty action <code>new</code> and <code>destroy</code>. <br  />
Inspecting the debug information, the submission results in a <code>params</code>
hash containing the email and password under the key <code>session</code> (see
below). As weas in the case of the user signup, these parameters form
a nested hash like the one for the user signup. In particular,
<code>params</code> contains a nested hash of the form: <code>{ session: { password:
"...", email: "..." } }</code>. This means that <code>params[:session]</code> is itself
a hash. Hence, inside the <code>create</code> action the <code>params</code> hash has all
the information needed to authenticate users by email and
password.
</p>
<div class="org-src-container">

<pre class="src src-ruby">--- !rub/object:ActionController::Parameters
session: !ruby/object:ActionController::Parameters
  parameters: !ruby/hash:ActiveSupport::HashWithIndifferentAccess
    email: ...
    password: ...
...
</pre>
</div>
<p>
 Not coincidentally, we already have a method for
<code>User.find_by</code> method provided by <code>has_secure_password</code>. Recall,
<code>authenticate</code> returns false for an invalid authentication. Our
strategy for user login can be summarized as 
</p>
<pre class="example">
if user exists AND user is authenticated
 user = find user by (lowercase) email
 Log the user in and redirect to the user's show page
else
 Create an error message
 render 'new'
</pre>
<p>
The <code>&amp;&amp;</code> (logical <i>and</i>) is used to determine if the resulting user is
valid. Taking into account that any object other than <code>nil</code> and
<code>false</code> itself is <code>true</code> in a boolean context, the possibilities are:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">User</td>
<td class="left">Password</td>
<td class="left">a &amp;&amp; b</td>
</tr>

<tr>
<td class="left">nonexistent</td>
<td class="left">anything</td>
<td class="left">(nil &amp;&amp; [anything]) == false</td>
</tr>

<tr>
<td class="left">valid user</td>
<td class="left">wrong password</td>
<td class="left">(true &amp;&amp; false) == false</td>
</tr>

<tr>
<td class="left">valid user</td>
<td class="left">right password</td>
<td class="left">(true &amp;&amp; true) == true</td>
</tr>
</tbody>
</table>

<p>
Rendering with a flash message. <br  />
Recall- we displayed the signup errors using the User model error
messages:
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/views/shared/_error_message.html.erb
&lt;% if @user.errors.any? %&gt;
&lt;div id="error_explanation"&gt;
  &lt;div class="alert alert-danger"&gt;
    The form contains &lt;%= pluralize(@user.errors.count, "error") %&gt;
  &lt;/div&gt;
  &lt;ul&gt;
    &lt;% @user.errors.full_messages.each do |msg| %&gt;
    &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;% end %&gt;

./app/views/users/new.html.erb
  &lt;%= form_for(@user, url: signup_path) do |f| %&gt;
    &lt;%= render 'shared/error_messages' %&gt;
    ...
  &lt;% end %&gt;
</pre>
</div>
<p>
The errors are associated w/ a particular Active Record object, but
this strategy won't work here bc the session isn't an active record
model. Instead, we'll put a message in the flash to be displayed upon
failed login as:
</p>
<pre class="example">
flash[:danger] = 'Invalid email/password combination'
</pre>
<p>
Bc of the flash message display in the site layout, the
<code>flash[:danger]</code> message automatically gets displayed and styled by
the Bootstrap CSS:
#+BEIGN<sub>SRC</sub> ruby
./app/views/layouts/application.html.erb
&lt;div class="container"&gt;
  &lt;% flash.each do |message<sub>type</sub>, message| %&gt;
  &lt;div class="alert alert-&lt;%= message<sub>type</sub> %&gt;"&gt;
    &lt;%= message %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
#+END<sub>SRC</sub>
Unfortunately, this code isn't quite right. The page looks fine, but
the issue is that the contents of the flash persist for one <i>request</i>,
but&#x2013;unlike a redirect&#x2013; re-rendering a template with <code>render</code> doesn't
count as a request. The result is the flash message persists one
request longer than we want. <br  />
Ex- submitting an invalid login information and then clicking on the
Home page results in the flash message displayed a second time. We
will fix this belimish next.
</p>

<p>
A flash test. <br  />
The incorrect flash behavior is a minor bug in our application. This
situation (according to our testing guidelines Box 3.3) is exactly the
sort of situation where we should write a test to catch the error so
it doesn't recur. <br  />
We write a short integration test for the login form submission before
proceeding. The benefits of this integration test are:
</p>
<ul class="org-ul">
<li>documenting the bug,
</li>
<li>preventing a regression,
</li>
<li>and this weill also give us a good foundation for further
integration tests of login and layout. 
</li>
</ul>
<p>
We start by generating an integration test for our application's login
behavior <code>$ rails generate integration_test users_login</code>. Next, we
need a test to capture the sequence of behavior where the bug occurs:
</p>
<ol class="org-ol">
<li>visit the login path
</li>
<li>verify the new sessions form renders properly
</li>
<li>post to the session path with an invalid <code>params</code> hash
</li>
<li>verify that the new sessions form gets re-rendered and that a flash
message appears
</li>
<li>visit another page (such as the Home page)
</li>
<li>verify that the flash message <i>doesn't</i> appear on the new page
</li>
</ol>
<div class="org-src-container">

<pre class="src src-ruby">./test/integration/users_login_test.rb
class UsersLoginTest &lt; ActionDispatch::IntegrationTest
  test "login with invalid information"
    get login_path
    assert_template 'sessions/new'
    post login_path, params: { session: { email: "", password: "" } )
    assert_template 'sessions/new'
</pre>
</div>

<p>
<b>Logging in</b>. <br  />
Now that our login can handle invalid submissions, the next step is to
handle valid submissions correctly by actually loggin a user in. We
log the user in w/ a temporary session cookie that expires
automatically upon the browser close. We add sessions that persist
even after closing the browser. <br  />
Implementing sessions involves defining a large number of related
functions for use accross multiple controllers and views. Recall- Ruby
provides a <i>module</i> facility for packaging such functions in one
place. Conveniently, a Sessions helper module was generated
automatically when generating the Sessions controller. Such helpers
are automatically included in Rails views; by including the module
into the base class of all controllers (the Application controller),
we arrange to make them available in our controllers as well. 
</p>
<pre class="example">
class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
  Include SessionsHelper
end 
</pre>

<p>
The <code>log_in</code> method. <br  />
Logging a user in is simple w/ the help of the <code>session</code> method
defined by Rails (seperate and distinct from the Sessions
controller). We can treat <code>session</code> as if it were a hash, and assign
to it: <code>session[:user_id] = user.id</code>. This places a temporary cookies
on the user's browser containing an encrypted version of the user's
id, which allows us to retrieve the id on subsequent pages using 
<code>session[:user_id]</code>. The temporary cookie created by the <code>session</code>
method expires immediately when te browser is closed. <br  />
Bc we want to use the same login technique in a couple different
places, we'll define a method called <code>log_in</code> in the Sessions helper
(see below). Bc temp cookies created using the <code>session</code> method are
automatically encrypted, the code below is secure (applies only to
temp sessions via <code>session</code> method, not w/ sessions via <code>cookie</code>
method). Permanent cookies are vulnerable to session hijacking attacks
(cf. ch9). <br  />
</p>

<div class="org-src-container">

<pre class="src src-ruby">./app/helpers/sessions_helper.rb
module SessionsHelper
  # Logs in the given user.
  def log_in(user)
    session[:user_id] = user.id
  end
end

./app/controllers/sessions_controller.rb
class SessionsController &lt; ApplicationController
  ...
  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user &amp;&amp; user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end
  ...
end
</pre>
</div>


<p>
Current user. <br  />
Now that we placed the user's id securely in the temporary session, we
are now in a position to retrieve it on subsequent pages, which we'll
do by defining a <code>current_user</code> method to find the user in the
database corresponding to the session id. The purpose of the
<code>current_user</code> is to allow constructions such as
</p>
<pre class="example">
&lt;%= current_user.name %&gt;
</pre>
<p>
and
</p>
<pre class="example">
redirect_to current_user
</pre>
<p>
To find the current user, one possibility is to use the <code>find</code> method,
as on the user profile page <code>User.find(session[:user_id])</code>. Recall-
<code>find</code> raises an exception if the user id doesn't exist. This behavior
is appropriate on the user profile page bc it will only happen if the
id is invalid, but in the present case <code>session[:user_id]</code> will often
be <code>nil</code> (i.e. for non-logged-in users). To handle this possiblity,
we'll use the same <code>find_by</code> method used to find by email address in
the <code>create</code> method, with <code>id</code> in place of <code>email</code>:
</p>
<pre class="example">
User.find_by(id: session[:user_id])
</pre>
<p>
Rather than raising an exception, this method returns <code>nil</code>
(indicating no such user) if the id is invalid. This works fine, but
it hits the database multiple times if, e.g. <code>current_user</code> appeared
multiple times on a page. Instead, we'll follow a common Ruby
convention by storing the result of <code>User.find_by</code> in an instance
variable, which hits the db the first time but returns the instance
variable immediately on subsequent invocations: 
</p>
<div class="org-src-container">

<pre class="src src-ruby">if @current_user.nil?
  @current_user = User.find_by(id: session[:user_id])
else
  @current_user
end

... more sufficiently rewritten as
@current_user = @current_user || User.find_by(id: seesion[:user_id])

... idiomatically as
@current_user ||= User.find_by(id: session[:user_id])
</pre>
</div>

<p>
Changing the layout links. <br  />
The first practical application for logging in involves changing the
layout links based on the login status. In particular, we add links
for logging out, links for user settings, for listing all users, and
for the current user's profile page. <br  />
At this point, I would consider writing an integration test to capture
the behavior described above. As you become mroe familiar w/ the
testing tools in Rails you may find yourself more inclined to write
tests first. In this case, such a test involves several new ideas, so
for now it's best to defer for later. <br  />
The way to change links in the site layout involves using an if-else
statement inside embedded Ruby to show one set of links if the user is
logged in and another, otherwise (see below). We use a <code>logged_in?</code>
boolean method, which determines if a user has logged in. <br  />
Recall- a user is logged in if there is a current user in the session,
i.e., if <code>current_user</code> is not <code>nil</code>. Checking for his requires the
use of the 'not' operator written using an exclamation point <code>!</code> (read
'bang'). The resulting <code>logged_in?</code> method appears below. <br  />
We're now ready to change the layout links if a user is logged
in. There are four new links (two stubbed out). Below is a concise
version of the conditional header template. <br  />
We need to include Bootstrap's ability to make dropdown menus (see
below). Not in particular the inclusion of the special Bootstrap CSS
classes such as <code>dropdown</code>, <code>dropdown-menu</code>, etc. To activate the
dropdown menu, we need to include Bootstrap's custom JavaScript
library in the Rails asset pipeline's <code>application.js</code> file. <br  />
</p>
<div class="org-src-container">

<pre class="src src-ruby"># conditional templating
  &lt;% if logged_in? %&gt;
    # Links for logged-in users
  &lt;% else %&gt;
    # Links for non-logged-in-users
  &lt;% end %&gt;

./app/helpers/sessions_helper
module SessionsHelper
  ...
  # Return true if the user is logged in, false otherwise.
  def logged_in?
    !current_user.nil?
  end
  ...
end

./app/views/layouts/_header.html.erb
&lt;header class="navbar navbar-fixed-top navbar-inverse"&gt;
&lt;div class="container"&gt;
  &lt;nav&gt;
    &lt;ul class="nav navbar-nav navbar-right"&gt;
      &lt;li&gt;&lt;%= link_to "Home", root_path %&gt;&lt;/li&gt;
      &lt;li&gt;&lt;%= link_to "Help", help_path %&gt;&lt;/li&gt;
      &lt;% if logged_in? %&gt;
        &lt;li&gt;&lt;%= link_to "User", '#' %&gt;&lt;/li&gt;
        &lt;li class="dropdown-menu"&gt;
          &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;
            Accoutn
          &lt;/a&gt;
          &lt;ul class="dropdown-menu"&gt;
            &lt;li&gt;&lt;%= link_to "Profile", current_user %&gt;&lt;/li&gt;
            &lt;li&gt;&lt;%= link_to "Settings", '#' %&gt;&lt;/li&gt;
            &lt;li&gt;&lt;%= link_to "Log out", logout_path, method: delete %&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;% else %&gt;
        &lt;li&gt;&lt;%= link_to "Log in", login_path %&gt;&lt;/li&gt;
      &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;
&lt;/div&gt;
&lt;/header&gt;

./app/assets/javascript/application.js
//= require jquery
...
//= require bootstrap
...
</pre>
</div>

<p>
Testing layout changes. <br  />
Having verified by hand that the app is behaving properly upon
successful login, before moving on we'll write an integration test to
capture that behavior and catch regressions. <br  />
We build on the test the login integration test and write a series of
steps to verify the following sequence of actions:
</p>
<ol class="org-ol">
<li>visit the login path
</li>
<li>post valid information to the sessions path
</li>
<li>verify that the login link disappears
</li>
<li>verify that a logout link appears
</li>
<li>verify that a profile link appears
</li>
</ol>
<p>
In order to see these changes, our test needs to log in as a previously
registered user, which means that such a user must already exist in
the database. The default Rails way to do this is to use <i>fixtures</i>,
which are a way of organizing data to be loaded into the test
database (which we deleted so our email uniqueness tests would
pass). Now we're ready to start filling in the empty file w/ custom
fixtures of our own. <br  />
In the present case, we need only one user, whose information should
consist of a valid name and email address. Bc we'll need to log the
user in, we also have to include a valid password to compare w/ the
password submitted to the Sessions controller's <code>create</code>
action. Referring to the data model, we see that this means creating a
<code>password_digest</code> attribute for the user fixture, which we accomplish
by defining a <code>digest</code> method of our own. <br  />
Te password digest is created using bcrypt (via
<code>has_secure_password</code>), so we'll need to create the fixture password
using hte same method. By inspecting the secure password source code,
we find the metod is <code>BCrypt::Password.create(string, cost: cost)</code>
where <code>string</code> is the string to be hashed and <code>cost</code> is the <i>cost</i>
parameter that determines the computational cost to calculate the
hash. Using a high cost makes it computationally intractable to use
the hash to determine the original password, which is an important
security precaution in a production environment, but in tests we want
the <code>digest</code> metod to be as fast as possible. The secure password
source code has a line for this as well:
</p>
<pre class="example">
cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost
</pre>
<p>
There are several places we could put the resulting <code>digest</code> method,
but we'll have an opportunity to reuse <code>digest</code> in the User mode. This
suggest placing the method in <code>user.rb</code>. Bc we won't necessarily have
access to a user object when calculating the digest (as will be the
case in the fixutres file), we'll attach the digest method to the User
class itself, which makes it a class method. <br  />
Below, we define the <code>Foo</code> user fixture. Note, fixtures support
embedded Ruby, which allows us to use the User class method
<code>User.digest</code> to create a valid password digest for the test
user. Although, we've defined the <code>password_digest</code> attributes
required by <code>has_secure_password</code>, sometimes it's convenient to refer
to the plain (virtual) password as well. This is impossible to arrange
w/ fixtures, and adding a <code>password</code> attribute cuases Rails to
complain that there is no such column in the db (true). We'll make do
by adopting the convention that ll fixture users have the same
password <code>password</code>. <br  />
Having created a fixture w/ a valid user, we can retrieve it inside a
test as follows:
</p>
<pre class="example">
user = users(:foo)
</pre>
<p>
Here <code>users</code> corresponds to the fixture filename <code>user.yml</code>, while the
symbol <code>:foo</code> references user w/ the key shown. With the fixture user
as above, we can now write a test for the layout links by converting
the sequence enumerated at the beginning of this section into code
(see below). <br  />
We've used the <code>assert_redirected_to @user</code> to check the right
redirect target and followed the target by use of
<code>follow_redirect!</code>. We also verified the login link dsappears by
verifying there are <i>zero</i> login paths on the redirected page. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/models/user.rb
class User &lt; ApplicationRecord
  ...
  # Returns the hash digest of the given string.
  def User.digest(string)
    cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST :
                                                  BCrypt::Engine.cost
    BCrypt::Password.create(string, cost: cost)
  end
end

./test/fixtures/user.yml
foo:
  name: Foo Example
  email: foo@bar.baz
  password_digest: &lt;%= User.digest('password') %&gt;

./test/integration/users_login_test.rb
require 'test_helper'
class UsersLoginTest &lt; ActionDispatch::IntegrationTest
  def setup
    @user = users(:foo)
  end
  ...
  test "login with valid information" do
    get login_path
    post login_path, params: { session: { email: @user.email,
                                          password: 'password' } }
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'
    assert_select "a[href=?", login_path, count: 0
    ...
  end
end
</pre>
</div>

<p>
Login upon signup. <br  />
Newly registered users are not logged in by default. We log in new
users automatically as part of the signup process. To arrange this
behavior, all we need to do is add a call to <code>log_in</code> in the Users
controller <code>create</code> action (see below). <br  />
To arrange this behavior, all we need to do is add a call to the
<code>log_in</code> in the Users controller <code>create</code> action (right after we save
the newly created user). <br  />
To test the behavior, we can add a line to the test to check that the
user is logged in. It's helpful in this context to define an
<code>is_logged_in?</code> helper method to parallel the <code>logged_in?</code> helper
defined which returns <code>true</code> if there's a user id in the (test)
seesion and false otherwise. With the helper method, we can assert
that the user is logged in after signup by appending <code>assert
is_logged_in?</code> at the end of the <code>valid signup information</code> test. 
</p>

<p>
<b>Logging out</b>. <br  />
Our authentication model is to keep users logged in until they log out
explicitly. We add the necessary logout capability. Bc the "Log out"
link has already been defined, all we need is to write a valid
controller action to destroy user sessions. <br  />
So far, the Sessions controller actions have followed the RESTful
convention of using <code>new</code> for a login page and <code>create</code> to complete
the login. We'll continue this theme by using a <code>destroy</code> action to
delete sessions, i.e., to log out. Unlike the login functionality,
we'll only be logging out in one place, so we'll put the relevant code
directly in the <code>destroy</code> action. Wth a little refactoring, we will
also make the authentication machinery easier to test. <br  />
Logging out involves undoing the effects of the <code>log_in</code> method from
which involves deleting the user id from the ession. To do this, we
wuse the <code>delete</code> method as follows: <code>session.delete(:user_id)</code>. We
also set the current user to <code>nil</code>, although in the present case this
won't matter bc of an immediate redirect to the root URL. As with 
<code>log-in</code> and associated methods, we'll put the resulting <code>log_out</code>
method in the Sessions helper module (see below). <br  />
To test the logout machinery, we can add some steps to the user login
test. After logging in, we use <code>delete</code> to issue a <code>DELETE</code> request to
the logout path and verify the user is logged out and redirected to
the root URL (see below). We also check the login link reappears and
that the logout and profile links disappear. 
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/helpers/session_helper.rb
module SessionsHelper
  # Logs in the given user.
  def login(user)
    session[:user_id] = user.id
  end
  ...
  # Logs out the current user.
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end

./test/integration/users_login_test.rb
require 'test_helper'
class UsersLoginTest &lt; ActionDispatch::IntegrationTest
  ...
  test "login with valid information followed by logout" do
    get login_path
    ...
    assert is_logged_in?
    ...
    delete logout_path
    assert_not is_logged_in?
    assert_redirect_to root_url
    follow_redirect!
    assert_select "a[href=?]", login_path
    assert_select "a[href=?]", logout_path,      count: 0
    assert_select "a[href=?]", user_path(@user), count: 0
  end
end
</pre>
</div>

<p>
<b>Conclusion</b>. <br  />
What we learned in this chapter:
</p>
<ul class="org-ul">
<li>Rails can maintain state from one page to the next using temporary
cookies via the session method. 
</li>
<li>The login form is designed to create a new session to log a user
in.
</li>
<li>The flash.now method is used for flash messages on rendered pages.
</li>
<li>Test-driven development is useful when debugging by reproducing the
bug in a test. 
</li>
<li>Using the session method, we can securely place a user id on the
browser to create a temporary session. 
</li>
<li>We can change features such as links on the layouts based on login
status. 
</li>
<li>Integration tests can verify correct routes, database updates, and
proper changes to the layout.  
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Updating, showing, and deleting users</h2>
<div class="outline-text-2" id="text-9">
<p>
We complete the REST actions for the Users resource by adding <code>edit</code>,
<code>update</code>, <code>index</code>, and <code>destroy</code> actions. We'll start by giving users
the ability to update their profiles, which will also provide a
natural opportunity to enforce an authorization model (made possibly
by the authentication code in ch8). <br  />
Then we'll make a listing of all users (also requiring
authentication), which will motivate the introduction of sample data
and pagination. <br  />
Finally, we'll add the ability to destroy users, wiping them clear
from the databse We create a privileged class of administrative users
authorized to delete other users. 
</p>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Updating users</h3>
<div class="outline-text-3" id="text-9-1">
<p>
The pattern for editing user information closely parallels that for
creating new users (see ch7). 
</p>
<ul class="org-ul">
<li>creating new users
<ul class="org-ul">
<li><code>new</code> action renders a view for a new users
</li>
<li><code>create</code> action responds to a <code>POST</code>
</li>
<li>anyone can sign up
</li>
</ul>
</li>
<li>editing users
<ul class="org-ul">
<li><code>edit</code> action renders a view to edit users
</li>
<li><code>update</code> action responds to a <code>PATCH</code>
</li>
<li>only the current user can update their information
</li>
</ul>
</li>
</ul>
<p>
The authentication machinery from ch8 enables the use of a <i>before
filter</i> to ensure that this is the case.
</p>

<p>
<b>Edit form</b>. <br  />
We begin w/ the edit form which consists of name, email, and
password/password confirmation fields to update the user profile. An
edit working page = fill User controler <code>edit</code> action + user edit
view. The <code>edit</code> action requires pulling the relevant user out of the
database. The URL for a user's edit page is <code>/users/1/edit</code> (assuming
the user's id is <code>1</code>). <br  />
The corresponding edit view (see below) closely resembles the new user
view. Te use of
</p>
<pre class="example">
target="_blank"
</pre>
<p>
in the Gravatar link is a neat trick to get the browser to open the
page in a new window or tab, which is sometimes convenient behavior
when linking to third-party sites. There is a minor security issue
associated w/ it; dealing w/ the details is covered below. <br  />
W/ the <code>@user</code> instance variable, the edit page should render properly
the 'Name' and 'Email' fields w/ the corresponding <code>@user</code>
attributes. <br  />
Since web browsers can't natively send <code>PATCH</code> requests (as required
by the REST conventions, Rails fakes it w/ a <code>POST</code> request and a
hidden <code>input</code> field (found in the HTML browser view of edit, see
below). The code <code>form_for(@user)</code> is exactly the same code as the one
from the new user view. How does Raisl know to use a <code>POST</code> request
for new users and a <code>PATCH</code> for editing users? Te answer is that it is
possible to tell whether a user is new or already exists in the
database via Active Record's <code>new_record?</code> boolean method (see
below). <br  />
We fill in the URL of the settings link to the site navigation via the
<code>edit_user_path</code> named route, together w/ the <code>current_user</code> helper
method (see below).
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/controller/users_controller.rb
class UsersController &lt; ApplicationController
  ...
  def edit
    @user = User.find(params[:id])
  end
  ...
end

./app/views/users/edit.html.erb
&lt;%= provide(:title, "Edit user") %&gt;
&lt;h1&gt;Update your profile&lt;/h1&gt;
&lt;div class="row"&gt;
  &lt;div class="col-md-6 col-md-offset-3"&gt;
    &lt;%= form_for(@user) do |f| %&gt;
      &lt;%= render 'shared/error_message' %&gt;

      &lt;%= f.label :name %&gt;
      &lt;%= f.text_field :name, class: 'form-control' %&gt;

      &lt;%= f.label :email %&gt;
      &lt;%= f.email_field :email, class: 'form-control' %&gt;

      &lt;%= f.label :password %&gt;
      &lt;%= f.password_field :password, class: 'form-control' %&gt;

      &lt;%= f.label :password_confirmation %&gt;
      &lt;%= f.password_field :password_confirmation, class: 'form-control' %&gt;

      &lt;%= f.submit "Save changes", class: "btn btn-primary" %&gt;
    &lt;% end %&gt;
  &lt;div class="gravatar_edit"&gt;
    &lt;%= gravatar_for @user %&gt;
    &lt;a href="..." target="_blank"&gt;change&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

./app/views/layouts/_header.html.erb
...
&lt;li&gt;&lt;%= link_to "Settings", edit_user_path(current_user) %&gt;&lt;/li&gt;
...

http://localhost:3000/users/1/edit
&lt;form accept-charset="UTF-8" action="/users/1" class="edit_user"
        id="edit_user_1" method="post"&gt;
  &lt;input name="_method" type="hidden" value="patch" /&gt;
  ...
&lt;/form&gt;


When constructing a form using form_for(@user), Rails uses POST if @user.new_record? is true and PATCH if it is false.
$ rails console
&gt;&gt; User.new.new_record?
=&gt; true
&gt;&gt; User.first.new_record?
=&gt; false
</pre>
</div>

<p>
<b>Unsuccessful edits</b>. <br  />
We start by creating an <code>update</code> action, which uses
<code>update_attributes</code> to update the user based on the submitted <code>params</code>
hash. With invalid information, the update attempt returns <code>false</code>, so
the <code>else</code> branch renders the edit page. We've seen this pattern
before; the structure parallels the first version of the <code>create</code>
action (see below). <br  />
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/controllers/users_controller.rb 
class UsersController &lt; ApplicationController
  ...
  def update
    @user = User.find(params[:id])
    if @user.update_attributes(user_params)
      # Handle a successful update.
    else
      render 'edit'
  end
</pre>
</div>

<p>
<b>Testing unsuccessful edits</b>. <br  />
Following the testing guidelines, we write an integration test to
catch any regressions. First we write a simple test of an unsuccessful
edit. Note the patch method to issue a <code>PATCH</code> request, which follows
the same pattern as <code>get</code>, <code>post</code>, and <code>delete</code>.
</p>
<div class="org-src-container">

<pre class="src src-ruby">class UsersEditTest &lt; ActionDispatch::IntegrationTest
  def setp
    @user = users(:foo)
  end

  test "unsuccessful edit" do
    get edit_user_path(@user)
    assert_template 'users/edit'
    patch user_path(@user), params: { user: { name:  "",
                                              email: "foo@invalid",
                                              password:             "foo",
                                              password_confirmation:"bar" } }
    assert_template 'users/edit'
  end
end
</pre>
</div>

<p>
<b>Successful edits (w/ TDD)</b>. <br  />
We get the edit form to work. Editing the profile images is already
functional since we've outsourced images upload to the Gravatar
website; we can edit Gravatars by clicking the 'change' link. Let's
get the rest of the user edit functionality working. <br  />
As we get more comfortable w/ testing, you might find that it's useful
to write integration tests before writing the app code instead of
after. In this context, such tests are sometimes known as <i>acceptance
tests</i>, since they determine when a particular feature should be
acceptable as complete. To see how this works, we'll complete the user
edit feature using test-driven development. <br  />
We'll test for the correct behavior of updating users w/ the following
behavior in mind:
</p>
<ul class="org-ul">
<li>we submit valid information
</li>
<li>we check for a nonempty flash message and a successful redirect to
the profile page
</li>
<li>while also verifying that the user's information correctly changed
in the database
</li>
</ul>
<p>
Note- the password and confirmation are black, which is convenient for
users who don't want to update their passwords every time they update
their names or email addresses. Note also the use of <code>@user.reload</code> to
reload the user's values from the database and confirm that they were
successfully updated. 
#+BEGIN<sub>SRC</sub> ruby
./test/integration/users<sub>edit</sub>.rb
class UserEditTest &lt; ActionDispatch::IntegrationTest
  &#x2026;
  test "successful edit" do
    get edit<sub>user</sub><sub>path</sub>(@user)
    assert<sub>template</sub> 
#+END<sub>SR</sub>
</p>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Authorization</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Authentication allows us to identify users of our site. While
authorization allows us lets us control what they can do. <br  />
We're now in a position to implement authorization. Although the edit
and update actions are functionally complete, they allow anyone
(including non-logged-in users) to access either action. Any logged-in
user can update the information for any other user. In this section,
we'll implement a security model that requires users to be logged in
an prevents them from updating any information other than their
own. <br  />
We handle the case of non-logged-in users who try to access a
protected page to which they might normally have access to. 
</p>

<p>
<b>Requiring logged-in users</b>. <br  />
To implement forwarding behavior, we use a <i>before filter</i> in the
Users controller. Before filters arrange for a particular method to be
called before the given actions. To require users to be logged in, we
define the <code>logged_in_user</code> method and invoke it using
<code>before_action :logged_in_user</code>. <br  />
By default, before filters apply to <i>every</i> action in a controller, so
here we restrict the filter to act only on <code>:edit</code> and <code>:update</code>
action by passing the appropriate <code>only:</code> option hash. <br  />
If we remove our security model, that is the before filter call to
<code>logged_in_user</code>, our test suite is still GREEN (comment out the
before hook and the controller '&#x2026; when not logged in' tests). Of all
the regressions we'd like our test suite to catch, a massive security
hole like this is #1. So the code w/out the our security model should
definitely be RED. <br  />
Bc the before filter operates on a per-action basis, we'll put the
corresponding tests in the Users controller test. The plan is to hit
the <code>edit</code> and <code>update</code> actions w/ the right kinds of requests and
verify that the flash is set and the user is redirected to the login
path. Notice the second test involves using the <code>patch</code> method to send
a <code>PATCH</code> request to <code>user_path(@user)</code> (which is then routed to the
<code>update</code> action in the Users controller).
</p>
<div class="org-src-container">

<pre class="src src-ruby">./app/controllers/users_controller.rb
class UsersController &lt; ApplicationController
  before_action :logged_in_user, only: [:edit, :update]
  ...
  private
    ...
    # Before filters

    # Confirm a logged-in user.
    def logged_in_user
      unless logged_in?
        flash[:danger] = "Please log in."
        redirect_to login_url
      end
    end
end

./test/controllers/users_controller_test.rb
class UsersController &lt; ActionDispatch::IntegrationTest
  def setup
    @user = user(foo)
  end
  ...
  test "should redirect edit when not logged in" do
    get edit_user_path(@user)
    assert_not flash.empty?
    assert_redirected_to login_url
  end
  test "should redirect update when not logged in" do
    patch user_path(@user), params: { user: { name: @user.name,
                                              email: @user.email } }
    assert_not flash.empty?
    assert_redirected_to login_url
  end
end
</pre>
</div>

<p>
Requiring the right user. <br  />
We've managed to only allow registered users to log in. Public users
no longer have access to edit nor update currently registered
users. But even logged in usres should only be allowed to edit their
own information. <br  />
As we saw it's easy to have a test suite that misses an essential
security flaw, so we proceed using test-driven development to be sure
our code implements the security model correctly. To do this, we'll
add tests to the Users controller test to complement the ones shown
below. <br  />
To ensure usres cannot edit other users' information, we need to be
able to log in as a second user. This means adding a second user to our
users fixture (add user <code>bar</code>). By using the <code>log_in_as</code> method, we
can test the <code>edit</code> and <code>update</code> actions. Note that we expect to
redirect users to the root path instead of the login path bc a user
trying to edit a different user would already be logged in. <br  />
To redirect users trying to edit another user's profile, we'll add a
second method called <code>correct_user</code>, together w/ a before filter
to call it. Note that the <code>current_user</code> defines the <code>@user</code>
variable, which shows that we can eliminate the <code>@user</code> assignment in
the <code>edit</code> and <code>update</code> actions. 
</p>
<div class="org-src-container">

<pre class="src src-ruby"></pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: az</p>
<p class="date">Created: 2016-09-19 Mon 02:00</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
